{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Connaisseur \u2693\ufe0e A Kubernetes admission controller to integrate container image signature verification and trust pinning into a cluster. What is Connaisseur? \u2693\ufe0e Connaisseur ensures integrity and provenance of container images in a Kubernetes cluster. To do so, it intercepts resource creation or update requests sent to the Kubernetes cluster, identifies all container images and verifies their signatures against pre-configured public keys. Based on the result, it either accepts or denies those requests. Connaisseur is developed under three core values: Security , Usability , Compatibility . It is built to be extendable and currently aims to support the following signing solutions: Notary (V1) / Docker Content Trust sigstore / Cosign Notary V2 (PLANNED) It provides several additional features: Metrics : get prometheus metrics at /metrics Alerting : send alerts based on verification result Detection Mode : warn but do not block invalid images Namespaced Validation : restrict validation to dedicated namespaces Automatic Child Approval : configure approval of Kubernetes child resources Feel free to reach out via GitHub Discussions ! Quick start \u2693\ufe0e Getting started to verify image signatures is only a matter of minutes: Only try this out on a test cluster as deployments with unsigned images will be blocked. Connaisseur comes pre-configured with public keys for its own repository and Docker's official images (official images can be found here ). It can be fully configured via helm/values.yaml . For a quick start, clone the Connaisseur repository: git clone https://github.com/sse-secure-systems/connaisseur.git Next, install Connaisseur via Helm : helm install connaisseur helm --atomic --create-namespace --namespace connaisseur Once installation has finished, you are good to go. Successful verification can be tested via official Docker images like hello-world : kubectl run hello-world --image = docker.io/hello-world Or our signed testimage : kubectl run demo --image = docker.io/securesystemsengineering/testimage:signed Both will return pod/<name> created . However, when trying to deploy an unsigned image: kubectl run demo --image = docker.io/securesystemsengineering/testimage:unsigned Connaisseur denies the request and returns an error (...) Unable to find signed digest (...) . Since the images above are signed using Docker Content Trust, you can inspect the trust data using docker trust inspect --pretty <image-name> . To uninstall Connaisseur use: helm uninstall connaisseur --namespace connaisseur Congrats you just validated the first images in your cluster! To get started configuring and verifying your own images and signatures, please follow our setup guide . How does it work? \u2693\ufe0e Integrity and provenance of container images deployed to a Kubernetes cluster can be ensured via digital signatures. On a very basic level, this requires two steps: Signing container images after building Verifying the image signatures before deployment Connaisseur aims to solve step two. This is achieved by implementing several validators , i.e. configurable signature verification modules for different signing solutions (e.g. Notary V1). While the detailed security considerations mainly depend on the applied solution, Connaisseur in general verifies the signature over the container image content against a trust anchor or trust root (e.g. public key) and thus let's you ensure that images have not been tampered with (integrity) and come from a valid source (provenance). Trusted digests \u2693\ufe0e But what is actually verified? Container images can be referenced in two different ways based on their registry, repository, image name ( <registry>/<repository>/<image name> ) followed by either tag or digest: tag: docker.io/library/nginx: 1.20.1 digest: docker.io/library/nginx@ sha256:af9c...69ce While the tag is a mutable, human readable description, the digest is an immutable, inherent property of the image, namely the SHA256 hash of its content. This also means that a tag can correspond to varying digests whereas digests are unique for each image. The container runtime (e.g. containerd) compares the image content with the received digest before spinning up the container. As a result, Connaisseur just needs to make sure that only trusted digests (signed by a trusted entity) are passed to the container runtime. Depending on how an image for deployment is referenced, it will either attempt to translate the tag to a trusted digest or validate whether the digest is trusted. How the digest is signed in detail, where the signature is stored, what it is verfied against and how different image distribution and updating attacks are mitigated depends on the signature solutions. Mutating admission controller \u2693\ufe0e How to validate images before deployment to a cluster? The Kubernetes API is the fundamental fabric behind the control plane. It allows operators and cluster components to communicate with each other and, for example, query, create, modify or delete Kubernetes resources. Each request passes through several phases such as authentication and authorization before it is persisted to etcd . Among those phases are two steps of admission control : mutating and validating admission. In those phases the API sends admission requests to configured webhooks (admission controllers) and receives admission responses (admit, deny, or modify). Connaisseur uses a mutating admission webhook, as requests are not only admitted or denied based on the validation result but might also require modification of contained images referenced by tags to trusted digests. The webhook is configured to only forward resource creation or update requests to the Connaisseur service running inside the cluster, since only deployments of images to the cluster are relevant for signature verification. This allows Connaisseur to intercept requests before deployment and based on the validation: admit if all images are referenced by trusted digests modify if all images can be translated to trusted digests deny if at least one of the requested images does not have a trusted digest Image policy and validators \u2693\ufe0e Now, how does Connaisseur process admission requests? A newly received request is first inspected for container image references that need to be validated (1). The resulting list of images referenced by tag or digest is passed to the image policy (2). The image policy matches the identified images to the configured validators and corresponding trust roots (e.g. public keys) to be used for verification. Image policy and validator configuration form the central logic behind Connaisseur and are described in detail und basics . Validation is the step where the actual signature verification takes place (3). For each image, the required trust data is retrieved from external sources such as Notary server, registry or sigstore transparency log and validated against the pre-configured trust root (e.g. public key). This forms the basis for deciding on the request (4). In case no trusted digest is found for any of the images (i.e. either no signed digest available or no signature matching the public key), the whole request is denied. Otherwise, Connaisseur translates all image references in the original request to trusted digests and admits it (5). Compatibility \u2693\ufe0e Supported signature solutions and configuration options are documented under validators . Connaisseur supports Kubernets v1.16 and higher. It is expected to be compatible with most Kubernetes services and has been successfully tested with: K3s \u2705 kind \u2705 MicroK8s \u2705 (enable DNS addon via sudo microk8s enable dns ) minikube \u2705 Amazon Elastic Kubernetes Service (EKS) \u2705 Azure Kubernetes Service (AKS) \u2705 Google Kubernetes Engine \u2705 SysEleven MetaKube \u2705 All registry interactions use the OCI Distribution Specification that is based on the Docker Registry HTTP API V2 which is the standard for all common image registries. For using Notary (V1) as a signature solution, only some registries provide the required Notary server attached to the registry with e.g. shared authentication. Connaisseur has been tested with the following Notary (V1) supporting image registries: Docker Hub \u2705 Harbor \u2705 Azure Container Registry (ACR) \u2705 (check our configuration notes ) In case you identify any incompatibilities, please create an issue Versions \u2693\ufe0e The latest stable version of Connaisseur is available on the master branch. Releases follow semantic versioning standards to facilitate compatibility. For each release, a signed container image tagged with the version is published in the Connaisseur Docker Hub repository . Latest developments are available on the develop branch, but should be considered unstable and no pre-built container image is provided. Development \u2693\ufe0e Connaisseur is open source and open development. We try to make major changes transparent via Architecture Decision Records (ADRs) and announce developments via GitHub Discussions . Information on responsible disclosure of vulnerabilities and tracking of past findings is available in the Security Policy . Bug reports should be filed as GitHub issues to share status and potential fixes with other users. We hope to get as many direct contributions and insights from the community as possible to steer further development. Please refer to our contributing guide , create an issue or reach out to us via GitHub Discussions Wall of fame \u2693\ufe0e Thanks to all the fine people directly contributing commits/PRs to Connaisseur: Big shout-out also to all who support the project via issues, discussions and feature requests Resources \u2693\ufe0e Several resources are available to learn more about Connaisseur and related topics: \" Container Image Signatures in Kubernetes \" - blog post (full introduction) \" Integrity of Docker images \" - talk at Berlin Crypto Meetup ( The Update Framework , Notary , Docker Content Trust & Connaisseur [live demo]) \" Verifying Container Image Signatures from an OCI Registry in Kubernetes \" - blog post (experimental support of sigstore / Cosign ) \" Verify Container Image Signatures in Kubernetes using Notary or Cosign or both \" - blog post (Connaisseur v2.0 release)","title":"Overview"},{"location":"#welcome-to-connaisseur","text":"A Kubernetes admission controller to integrate container image signature verification and trust pinning into a cluster.","title":"Welcome to Connaisseur"},{"location":"#what-is-connaisseur","text":"Connaisseur ensures integrity and provenance of container images in a Kubernetes cluster. To do so, it intercepts resource creation or update requests sent to the Kubernetes cluster, identifies all container images and verifies their signatures against pre-configured public keys. Based on the result, it either accepts or denies those requests. Connaisseur is developed under three core values: Security , Usability , Compatibility . It is built to be extendable and currently aims to support the following signing solutions: Notary (V1) / Docker Content Trust sigstore / Cosign Notary V2 (PLANNED) It provides several additional features: Metrics : get prometheus metrics at /metrics Alerting : send alerts based on verification result Detection Mode : warn but do not block invalid images Namespaced Validation : restrict validation to dedicated namespaces Automatic Child Approval : configure approval of Kubernetes child resources Feel free to reach out via GitHub Discussions !","title":"What is Connaisseur?"},{"location":"#quick-start","text":"Getting started to verify image signatures is only a matter of minutes: Only try this out on a test cluster as deployments with unsigned images will be blocked. Connaisseur comes pre-configured with public keys for its own repository and Docker's official images (official images can be found here ). It can be fully configured via helm/values.yaml . For a quick start, clone the Connaisseur repository: git clone https://github.com/sse-secure-systems/connaisseur.git Next, install Connaisseur via Helm : helm install connaisseur helm --atomic --create-namespace --namespace connaisseur Once installation has finished, you are good to go. Successful verification can be tested via official Docker images like hello-world : kubectl run hello-world --image = docker.io/hello-world Or our signed testimage : kubectl run demo --image = docker.io/securesystemsengineering/testimage:signed Both will return pod/<name> created . However, when trying to deploy an unsigned image: kubectl run demo --image = docker.io/securesystemsengineering/testimage:unsigned Connaisseur denies the request and returns an error (...) Unable to find signed digest (...) . Since the images above are signed using Docker Content Trust, you can inspect the trust data using docker trust inspect --pretty <image-name> . To uninstall Connaisseur use: helm uninstall connaisseur --namespace connaisseur Congrats you just validated the first images in your cluster! To get started configuring and verifying your own images and signatures, please follow our setup guide .","title":"Quick start"},{"location":"#how-does-it-work","text":"Integrity and provenance of container images deployed to a Kubernetes cluster can be ensured via digital signatures. On a very basic level, this requires two steps: Signing container images after building Verifying the image signatures before deployment Connaisseur aims to solve step two. This is achieved by implementing several validators , i.e. configurable signature verification modules for different signing solutions (e.g. Notary V1). While the detailed security considerations mainly depend on the applied solution, Connaisseur in general verifies the signature over the container image content against a trust anchor or trust root (e.g. public key) and thus let's you ensure that images have not been tampered with (integrity) and come from a valid source (provenance).","title":"How does it work?"},{"location":"#trusted-digests","text":"But what is actually verified? Container images can be referenced in two different ways based on their registry, repository, image name ( <registry>/<repository>/<image name> ) followed by either tag or digest: tag: docker.io/library/nginx: 1.20.1 digest: docker.io/library/nginx@ sha256:af9c...69ce While the tag is a mutable, human readable description, the digest is an immutable, inherent property of the image, namely the SHA256 hash of its content. This also means that a tag can correspond to varying digests whereas digests are unique for each image. The container runtime (e.g. containerd) compares the image content with the received digest before spinning up the container. As a result, Connaisseur just needs to make sure that only trusted digests (signed by a trusted entity) are passed to the container runtime. Depending on how an image for deployment is referenced, it will either attempt to translate the tag to a trusted digest or validate whether the digest is trusted. How the digest is signed in detail, where the signature is stored, what it is verfied against and how different image distribution and updating attacks are mitigated depends on the signature solutions.","title":"Trusted digests"},{"location":"#mutating-admission-controller","text":"How to validate images before deployment to a cluster? The Kubernetes API is the fundamental fabric behind the control plane. It allows operators and cluster components to communicate with each other and, for example, query, create, modify or delete Kubernetes resources. Each request passes through several phases such as authentication and authorization before it is persisted to etcd . Among those phases are two steps of admission control : mutating and validating admission. In those phases the API sends admission requests to configured webhooks (admission controllers) and receives admission responses (admit, deny, or modify). Connaisseur uses a mutating admission webhook, as requests are not only admitted or denied based on the validation result but might also require modification of contained images referenced by tags to trusted digests. The webhook is configured to only forward resource creation or update requests to the Connaisseur service running inside the cluster, since only deployments of images to the cluster are relevant for signature verification. This allows Connaisseur to intercept requests before deployment and based on the validation: admit if all images are referenced by trusted digests modify if all images can be translated to trusted digests deny if at least one of the requested images does not have a trusted digest","title":"Mutating admission controller"},{"location":"#image-policy-and-validators","text":"Now, how does Connaisseur process admission requests? A newly received request is first inspected for container image references that need to be validated (1). The resulting list of images referenced by tag or digest is passed to the image policy (2). The image policy matches the identified images to the configured validators and corresponding trust roots (e.g. public keys) to be used for verification. Image policy and validator configuration form the central logic behind Connaisseur and are described in detail und basics . Validation is the step where the actual signature verification takes place (3). For each image, the required trust data is retrieved from external sources such as Notary server, registry or sigstore transparency log and validated against the pre-configured trust root (e.g. public key). This forms the basis for deciding on the request (4). In case no trusted digest is found for any of the images (i.e. either no signed digest available or no signature matching the public key), the whole request is denied. Otherwise, Connaisseur translates all image references in the original request to trusted digests and admits it (5).","title":"Image policy and validators"},{"location":"#compatibility","text":"Supported signature solutions and configuration options are documented under validators . Connaisseur supports Kubernets v1.16 and higher. It is expected to be compatible with most Kubernetes services and has been successfully tested with: K3s \u2705 kind \u2705 MicroK8s \u2705 (enable DNS addon via sudo microk8s enable dns ) minikube \u2705 Amazon Elastic Kubernetes Service (EKS) \u2705 Azure Kubernetes Service (AKS) \u2705 Google Kubernetes Engine \u2705 SysEleven MetaKube \u2705 All registry interactions use the OCI Distribution Specification that is based on the Docker Registry HTTP API V2 which is the standard for all common image registries. For using Notary (V1) as a signature solution, only some registries provide the required Notary server attached to the registry with e.g. shared authentication. Connaisseur has been tested with the following Notary (V1) supporting image registries: Docker Hub \u2705 Harbor \u2705 Azure Container Registry (ACR) \u2705 (check our configuration notes ) In case you identify any incompatibilities, please create an issue","title":"Compatibility"},{"location":"#versions","text":"The latest stable version of Connaisseur is available on the master branch. Releases follow semantic versioning standards to facilitate compatibility. For each release, a signed container image tagged with the version is published in the Connaisseur Docker Hub repository . Latest developments are available on the develop branch, but should be considered unstable and no pre-built container image is provided.","title":"Versions"},{"location":"#development","text":"Connaisseur is open source and open development. We try to make major changes transparent via Architecture Decision Records (ADRs) and announce developments via GitHub Discussions . Information on responsible disclosure of vulnerabilities and tracking of past findings is available in the Security Policy . Bug reports should be filed as GitHub issues to share status and potential fixes with other users. We hope to get as many direct contributions and insights from the community as possible to steer further development. Please refer to our contributing guide , create an issue or reach out to us via GitHub Discussions","title":"Development"},{"location":"#wall-of-fame","text":"Thanks to all the fine people directly contributing commits/PRs to Connaisseur: Big shout-out also to all who support the project via issues, discussions and feature requests","title":"Wall of fame"},{"location":"#resources","text":"Several resources are available to learn more about Connaisseur and related topics: \" Container Image Signatures in Kubernetes \" - blog post (full introduction) \" Integrity of Docker images \" - talk at Berlin Crypto Meetup ( The Update Framework , Notary , Docker Content Trust & Connaisseur [live demo]) \" Verifying Container Image Signatures from an OCI Registry in Kubernetes \" - blog post (experimental support of sigstore / Cosign ) \" Verify Container Image Signatures in Kubernetes using Notary or Cosign or both \" - blog post (Connaisseur v2.0 release)","title":"Resources"},{"location":"CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct \u2693\ufe0e Our pledge \u2693\ufe0e In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our standards \u2693\ufe0e Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our responsibilities \u2693\ufe0e Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u2693\ufe0e This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u2693\ufe0e Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at connaisseur@securesystems.dev . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u2693\ufe0e This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our pledge"},{"location":"CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our standards"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our responsibilities"},{"location":"CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at connaisseur@securesystems.dev . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"CONTRIBUTING/","text":"Contributing \u2693\ufe0e We hope to steer development of Connaisseur from demand of the community and are excited about direct contributions to improve the tool! The following guide is meant to help you get started with contributing to Connaisseur. In case of questions or feedback, feel free to reach out to us . We are committed to positive interactions between all contributors of the project. To ensure this, please follow the Code of Conduct in all communications. Discuss problems, raise bugs and propose feature ideas \u2693\ufe0e We are happy you made it here! In case you want to share your feedback, need support, want to discuss issues from using Connaisseur in your own projects, have ideas for new features or just want to connect with us, please reach out via GitHub Discussions . If you want to raise any bugs you found or make a feature request, feel free to create an issue with an informative title and description. While issues are a great way to discuss problems, bugs and new features, a direct proposal via a pull request can sometimes say more than a thousand words. So be bold and contribute to the code as described in the next section ! In case you require a more private communication, you can reach us via connaisseur@securesystems.dev . Contribute to source code \u2693\ufe0e The following steps will help you make code contributions to Connaisseur and ensure good code quality and workflow. This includes the following steps: Set up your environment : Set up up your local environment to best interact with the code. Further information is given below . Make atomic changes : Changes should be atomic. As such, pull requests should contain only few commits, and each commit should only fix one issue or implement one feature, with a concise commit message. Test your changes : Test any changes locally for code quality and functionality and add new tests for any additional code. How to test is described below . Create semantic, conventional and signed commits : Any commits should follow a simple semantic convention to help structure the work on Connaisseur. The convention is described below . For security reasons and since integrity is at the core of this project, code merged into master must be signed. How we achieve this is described below . Create pull requests : We consider code review central to quality and security of code. Therefore, a pull request (PR) to the develop branch should be created for each contribution. It will be reviewed, and potential improvements may be discussed within the PR. After approval, changes will be merged and moved to the master branch with the next release. Set up the environment \u2693\ufe0e To start contributing, you will need to set up your local environment. First step is to get the source code by cloning this repository: git clone git@github.com:sse-secure-systems/connaisseur.git In order to review the effects of your changes, you should create your own Kubernetes cluster and install Connaisseur. This is described in the getting started . A simple starting point may be a minikube cluster with e.g. a Docker Hub repository for maintaining your test images and trust data. In case you make changes to the Connaisseur container image itself or code for that matter, you need to re-build the image and install it locally for testing. This requires a few steps: In helm/values.yaml , set imagePullPolicy to IfNotPresent . Configure your local environment to use the Kubernetes Docker daemon. In minikube, this can be done via eval (minikube docker-env) . Build the Connaisseur container image via make docker . Install Connaisseur as usual via make install . Test changes \u2693\ufe0e Tests and linting are important to ensure code quality, functionality and security. We therefore aim to keep the code coverage high. We are running several automated tests in the CI pipeline . Application code is tested via pytest and linted via pylint . When making changes to the application code, please directly provide tests for your changes. We recommend using black for autoformatting to simplify linting and reduce review effort. It can be installed via: pip3 install black To autoformat the code: black <path-to-repository>/connaisseur Changes can also be tested locally. We recommend the following approach for running pytest in a container: docker run -it --rm -v <path-to-repository>:/data --entrypoint=ash python:alpine cd data YARL_NO_EXTENSIONS=1 MULTIDICT_NO_EXTENSIONS=1 pip3 install -r requirements_dev.txt pytest --cov=connaisseur --cov-report=xml tests/ This helps identify bugs in changes before pushing. INFO We believe that testing should not only ensure functionality, but also aim to test for expected security issues like injections and appreciate if security tests are added with new functionalities. Besides the unit testing and before any PR can be merged, an integration test is carried out whereby: Connaisseur is successfully installed in a test cluster a non-signed image is deployed to the cluster and denied an image signed with an unrelated key is denied a signed image is deployed to the cluster and passed Connaisseur is successfully uninstalled You can also run this integration test on a local cluster. There is a more detailed guided on how to do that. If you are changing documentation, you can simply inspect your changes locally via: docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material Signed commits and pull requests \u2693\ufe0e All changes to the develop and master branch must be signed which is enforced via branch protection . This can be achieved by only fast-forwarding signed commits or signing of merge commits by a contributor. Consequently, we appreciate but do not require that commits in PRs are signed. A general introduction into signing commits can for example be found in the With Blue Ink blog . For details on setting everything up for GitHub, please follow the steps in the Documentation . Once you have generated your local GPG key, added it to your GitHub account and informed Git about it, you are set up to create signed commits. We recommend to configure Git to sign commits by default via: git config commit.gpgsign true This avoids forgetting to use the -S flag when committing changes. In case it happens anyways, you can always rebase to sign earlier commits: git rebase -i master You can then mark all commits that need to be signed as edit and sign them without any other changes via: git commit -S --amend --no-edit Finally, you force push to overwrite the unsigned commits via git push -f . Semantic and conventional commits \u2693\ufe0e For Connaisseur, we want to use semantic and conventional commits to ensure good readability of code changes. A good introduction to the topic can be found in this blog post . Commit messages should consist of header, body and footer. Such a commit message takes the following form: git commit -m \"<header>\" -m \"<body>\" -m \"<footer>\" The three parts should consist of the following: header : Comprises of a commit type (common types are described below) and a concise description of the actual change, e.g. fix: extend registry validation regex to custom ports . body (optional): Contains information on the motivation behind the change and considerations for the resolution, The current regex used for validation of the image name does not allow using non-default ports for the image repository name. The regex is extended to optionally provide a port number. . footer (optional): Used to reference PRs, issues or contributors and mark consequences such as breaking changes, e.g. Fix #<issue-number> We want to use the following common types in the header: build : changes to development and building ci : CI related changes docs : changes in the documentation feat : adding of new features fix : fixing an issue or bug refactor : adjustment of code base to improve code quality or performance but not adding a feature or fixing a bug test : testing related changes update : updating a dependency A complete commit message could therefore look as follows: git commit -m \"fix: extend registry validation regex to custom ports\" -m \"The current regex used for validation of the image name does not allow using non-default ports for the image repository name. The regex is extended to optionally provide a port number.\" -m \"Fix #3\" Enjoy! \u2693\ufe0e Please be bold and contribute!","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"We hope to steer development of Connaisseur from demand of the community and are excited about direct contributions to improve the tool! The following guide is meant to help you get started with contributing to Connaisseur. In case of questions or feedback, feel free to reach out to us . We are committed to positive interactions between all contributors of the project. To ensure this, please follow the Code of Conduct in all communications.","title":"Contributing"},{"location":"CONTRIBUTING/#discuss-problems-raise-bugs-and-propose-feature-ideas","text":"We are happy you made it here! In case you want to share your feedback, need support, want to discuss issues from using Connaisseur in your own projects, have ideas for new features or just want to connect with us, please reach out via GitHub Discussions . If you want to raise any bugs you found or make a feature request, feel free to create an issue with an informative title and description. While issues are a great way to discuss problems, bugs and new features, a direct proposal via a pull request can sometimes say more than a thousand words. So be bold and contribute to the code as described in the next section ! In case you require a more private communication, you can reach us via connaisseur@securesystems.dev .","title":"Discuss problems, raise bugs and propose feature ideas"},{"location":"CONTRIBUTING/#contribute-to-source-code","text":"The following steps will help you make code contributions to Connaisseur and ensure good code quality and workflow. This includes the following steps: Set up your environment : Set up up your local environment to best interact with the code. Further information is given below . Make atomic changes : Changes should be atomic. As such, pull requests should contain only few commits, and each commit should only fix one issue or implement one feature, with a concise commit message. Test your changes : Test any changes locally for code quality and functionality and add new tests for any additional code. How to test is described below . Create semantic, conventional and signed commits : Any commits should follow a simple semantic convention to help structure the work on Connaisseur. The convention is described below . For security reasons and since integrity is at the core of this project, code merged into master must be signed. How we achieve this is described below . Create pull requests : We consider code review central to quality and security of code. Therefore, a pull request (PR) to the develop branch should be created for each contribution. It will be reviewed, and potential improvements may be discussed within the PR. After approval, changes will be merged and moved to the master branch with the next release.","title":"Contribute to source code"},{"location":"CONTRIBUTING/#set-up-the-environment","text":"To start contributing, you will need to set up your local environment. First step is to get the source code by cloning this repository: git clone git@github.com:sse-secure-systems/connaisseur.git In order to review the effects of your changes, you should create your own Kubernetes cluster and install Connaisseur. This is described in the getting started . A simple starting point may be a minikube cluster with e.g. a Docker Hub repository for maintaining your test images and trust data. In case you make changes to the Connaisseur container image itself or code for that matter, you need to re-build the image and install it locally for testing. This requires a few steps: In helm/values.yaml , set imagePullPolicy to IfNotPresent . Configure your local environment to use the Kubernetes Docker daemon. In minikube, this can be done via eval (minikube docker-env) . Build the Connaisseur container image via make docker . Install Connaisseur as usual via make install .","title":"Set up the environment"},{"location":"CONTRIBUTING/#test-changes","text":"Tests and linting are important to ensure code quality, functionality and security. We therefore aim to keep the code coverage high. We are running several automated tests in the CI pipeline . Application code is tested via pytest and linted via pylint . When making changes to the application code, please directly provide tests for your changes. We recommend using black for autoformatting to simplify linting and reduce review effort. It can be installed via: pip3 install black To autoformat the code: black <path-to-repository>/connaisseur Changes can also be tested locally. We recommend the following approach for running pytest in a container: docker run -it --rm -v <path-to-repository>:/data --entrypoint=ash python:alpine cd data YARL_NO_EXTENSIONS=1 MULTIDICT_NO_EXTENSIONS=1 pip3 install -r requirements_dev.txt pytest --cov=connaisseur --cov-report=xml tests/ This helps identify bugs in changes before pushing. INFO We believe that testing should not only ensure functionality, but also aim to test for expected security issues like injections and appreciate if security tests are added with new functionalities. Besides the unit testing and before any PR can be merged, an integration test is carried out whereby: Connaisseur is successfully installed in a test cluster a non-signed image is deployed to the cluster and denied an image signed with an unrelated key is denied a signed image is deployed to the cluster and passed Connaisseur is successfully uninstalled You can also run this integration test on a local cluster. There is a more detailed guided on how to do that. If you are changing documentation, you can simply inspect your changes locally via: docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material","title":"Test changes"},{"location":"CONTRIBUTING/#signed-commits-and-pull-requests","text":"All changes to the develop and master branch must be signed which is enforced via branch protection . This can be achieved by only fast-forwarding signed commits or signing of merge commits by a contributor. Consequently, we appreciate but do not require that commits in PRs are signed. A general introduction into signing commits can for example be found in the With Blue Ink blog . For details on setting everything up for GitHub, please follow the steps in the Documentation . Once you have generated your local GPG key, added it to your GitHub account and informed Git about it, you are set up to create signed commits. We recommend to configure Git to sign commits by default via: git config commit.gpgsign true This avoids forgetting to use the -S flag when committing changes. In case it happens anyways, you can always rebase to sign earlier commits: git rebase -i master You can then mark all commits that need to be signed as edit and sign them without any other changes via: git commit -S --amend --no-edit Finally, you force push to overwrite the unsigned commits via git push -f .","title":"Signed commits and pull requests"},{"location":"CONTRIBUTING/#semantic-and-conventional-commits","text":"For Connaisseur, we want to use semantic and conventional commits to ensure good readability of code changes. A good introduction to the topic can be found in this blog post . Commit messages should consist of header, body and footer. Such a commit message takes the following form: git commit -m \"<header>\" -m \"<body>\" -m \"<footer>\" The three parts should consist of the following: header : Comprises of a commit type (common types are described below) and a concise description of the actual change, e.g. fix: extend registry validation regex to custom ports . body (optional): Contains information on the motivation behind the change and considerations for the resolution, The current regex used for validation of the image name does not allow using non-default ports for the image repository name. The regex is extended to optionally provide a port number. . footer (optional): Used to reference PRs, issues or contributors and mark consequences such as breaking changes, e.g. Fix #<issue-number> We want to use the following common types in the header: build : changes to development and building ci : CI related changes docs : changes in the documentation feat : adding of new features fix : fixing an issue or bug refactor : adjustment of code base to improve code quality or performance but not adding a feature or fixing a bug test : testing related changes update : updating a dependency A complete commit message could therefore look as follows: git commit -m \"fix: extend registry validation regex to custom ports\" -m \"The current regex used for validation of the image name does not allow using non-default ports for the image repository name. The regex is extended to optionally provide a port number.\" -m \"Fix #3\"","title":"Semantic and conventional commits"},{"location":"CONTRIBUTING/#enjoy","text":"Please be bold and contribute!","title":"Enjoy!"},{"location":"RELEASING/","text":"Releasing \u2693\ufe0e Releasing a new version of Connaisseur includes the following steps: check readiness adding a new version tag creating a changelog from commit messages creating a PR from develop (new version) to master (current version) pushing a new version of the Connaisseur image to Docker Hub merging in the PR & push tag creating release page shoot some trouble Check readiness \u2693\ufe0e Before starting the release, make sure everything is ready and in order: See that all tests are running smoothly. Check that documentation changes show up correctly here . Make sure the Connaisseur version is incremented correctly according to the changes. Make sure Connaisseur version in helm/values.yaml is matched to the appVersion in helm/Chart.yaml and the (chart) version in helm/Chart.yaml is increased according to semantic versioning if Helm templates have been touched. See if the docs announcements should be adjusted here . Consider making a GitHub Discussions announcement . Add new tag \u2693\ufe0e Before adding the new tag, make sure the Connaisseur version is updated in the helm/values.yaml and applies the semantic versioning guidelines: fixes increment PATCH version, non-breaking features increment MINOR version, breaking features increment MAJOR version. Then add the tag (on develop branch) with git tag v<new-conny-version> (e.g. git tag v1.4.6 ). Create changelog \u2693\ufe0e A changelog text, including all new commits from one to another version, can be automatically generated using the scrips/changelogger.py script. You have to update the two ref1 and ref2 variables in the main method with the the old and new Git tags. So if you e.g. want to release a new version from v1.4.5 to v1.4.6 , then you have to set ref1 = \"v1.4.5\" and ref2 = \"v1.4.6\" . Then simply run python scripts/changelogger.py > CHANGELOG.md , storing the changelog in a new file CHANGELOG.md (we won't keep this file, it's just for convenient storing purpose). This file will include all new commits, categorized by their type (e.g. fix, feat, docs, etc.), but may include some mistakes so take a manual look if everything looks in order. Things to look out for: multiple headings for the same category broken pull request links None appended on end of line Create PR \u2693\ufe0e Create a PR from develop to master , putting the changelog text as description and wait for someone to approve it. Push new Connaisseur image \u2693\ufe0e When the PR is approved and ready to be merged, first push the new Connaisseur image to Docker Hub, as it will be used in the release pipeline. Run make docker to build the new version of the docker image and then DOCKER_CONTENT_TRUST=1 docker image push securesystemsengineering/connaisseur:<new-version> to push and sign it. You'll obviously need the right private key and passphrase for doing so. You also need to be in the list of valid signers for Connaisseur. If not already (you can check with docker trust inspect securesystemsengineering/connaisseur --pretty ) you'll need to contact Philipp Belitz . Merge PR \u2693\ufe0e Run git checkout master to switch to the master branch and then run git merge develop to merge develop in. Then run git push and git push --tags to publish all changes and the new tag. Create release page \u2693\ufe0e Finally a release on GitHub should be created. Go to the Connaisseur releases page , then click Draft a new release . There you have to enter the new tag version, a title (usually Version <new-version> ) and the changelog text as description. Then click Publish release and you're done! (You can delete the CHANGELOG.md file now. Go and do it.) Shoot trouble \u2693\ufe0e Be aware that this isn't a completely fleshed out, highly available, hyper scalable and fully automated workflow, backed up by state-of-the-art blockchain technology and 24/7 incident response team coverage with global dominance! Not yet at least. For now things will probably break, so make sure that in the end everything looks to be in order and the new release can be seen on the GitHub page, tagged with Latest release and pointing to the correct version of Connaisseur. Good Luck!","title":"Releasing"},{"location":"RELEASING/#releasing","text":"Releasing a new version of Connaisseur includes the following steps: check readiness adding a new version tag creating a changelog from commit messages creating a PR from develop (new version) to master (current version) pushing a new version of the Connaisseur image to Docker Hub merging in the PR & push tag creating release page shoot some trouble","title":"Releasing"},{"location":"RELEASING/#check-readiness","text":"Before starting the release, make sure everything is ready and in order: See that all tests are running smoothly. Check that documentation changes show up correctly here . Make sure the Connaisseur version is incremented correctly according to the changes. Make sure Connaisseur version in helm/values.yaml is matched to the appVersion in helm/Chart.yaml and the (chart) version in helm/Chart.yaml is increased according to semantic versioning if Helm templates have been touched. See if the docs announcements should be adjusted here . Consider making a GitHub Discussions announcement .","title":"Check readiness"},{"location":"RELEASING/#add-new-tag","text":"Before adding the new tag, make sure the Connaisseur version is updated in the helm/values.yaml and applies the semantic versioning guidelines: fixes increment PATCH version, non-breaking features increment MINOR version, breaking features increment MAJOR version. Then add the tag (on develop branch) with git tag v<new-conny-version> (e.g. git tag v1.4.6 ).","title":"Add new tag"},{"location":"RELEASING/#create-changelog","text":"A changelog text, including all new commits from one to another version, can be automatically generated using the scrips/changelogger.py script. You have to update the two ref1 and ref2 variables in the main method with the the old and new Git tags. So if you e.g. want to release a new version from v1.4.5 to v1.4.6 , then you have to set ref1 = \"v1.4.5\" and ref2 = \"v1.4.6\" . Then simply run python scripts/changelogger.py > CHANGELOG.md , storing the changelog in a new file CHANGELOG.md (we won't keep this file, it's just for convenient storing purpose). This file will include all new commits, categorized by their type (e.g. fix, feat, docs, etc.), but may include some mistakes so take a manual look if everything looks in order. Things to look out for: multiple headings for the same category broken pull request links None appended on end of line","title":"Create changelog"},{"location":"RELEASING/#create-pr","text":"Create a PR from develop to master , putting the changelog text as description and wait for someone to approve it.","title":"Create PR"},{"location":"RELEASING/#push-new-connaisseur-image","text":"When the PR is approved and ready to be merged, first push the new Connaisseur image to Docker Hub, as it will be used in the release pipeline. Run make docker to build the new version of the docker image and then DOCKER_CONTENT_TRUST=1 docker image push securesystemsengineering/connaisseur:<new-version> to push and sign it. You'll obviously need the right private key and passphrase for doing so. You also need to be in the list of valid signers for Connaisseur. If not already (you can check with docker trust inspect securesystemsengineering/connaisseur --pretty ) you'll need to contact Philipp Belitz .","title":"Push new Connaisseur image"},{"location":"RELEASING/#merge-pr","text":"Run git checkout master to switch to the master branch and then run git merge develop to merge develop in. Then run git push and git push --tags to publish all changes and the new tag.","title":"Merge PR"},{"location":"RELEASING/#create-release-page","text":"Finally a release on GitHub should be created. Go to the Connaisseur releases page , then click Draft a new release . There you have to enter the new tag version, a title (usually Version <new-version> ) and the changelog text as description. Then click Publish release and you're done! (You can delete the CHANGELOG.md file now. Go and do it.)","title":"Create release page"},{"location":"RELEASING/#shoot-trouble","text":"Be aware that this isn't a completely fleshed out, highly available, hyper scalable and fully automated workflow, backed up by state-of-the-art blockchain technology and 24/7 incident response team coverage with global dominance! Not yet at least. For now things will probably break, so make sure that in the end everything looks to be in order and the new release can be seen on the GitHub page, tagged with Latest release and pointing to the correct version of Connaisseur. Good Luck!","title":"Shoot trouble"},{"location":"SECURITY/","text":"Security Policy \u2693\ufe0e Supported versions \u2693\ufe0e While all known vulnerabilities are listed below and we intent to fix vulnerabilities as soon as we become aware, both, Python and OS packages of the Connaisseur image may become vulnerable over time and we suggest to frequently update to the latest version of Connaisseur or rebuilding the image from source yourself. At present, we only support the latest version. We stick to semantic versioning, so unless the major version changes, updating Conaisseur should never break your installation. Known vulnerabilities \u2693\ufe0e Title Affected versions Fixed version Description initContainers not validated \u2264 1.3.0 1.3.1 Prior to version 1.3.1 Connaisseur did not validate initContainers which allowed deploying unverified images to the cluster. Reporting a vulnerability \u2693\ufe0e We are very grateful for reports on vulnerabilities discovered in the project, specifically as it is intended to increase security for the community. We aim to investigate and fix these as soon as possible. Please submit vulnerabilities to connaisseur@securesystems.dev .","title":"Security Policy"},{"location":"SECURITY/#security-policy","text":"","title":"Security Policy"},{"location":"SECURITY/#supported-versions","text":"While all known vulnerabilities are listed below and we intent to fix vulnerabilities as soon as we become aware, both, Python and OS packages of the Connaisseur image may become vulnerable over time and we suggest to frequently update to the latest version of Connaisseur or rebuilding the image from source yourself. At present, we only support the latest version. We stick to semantic versioning, so unless the major version changes, updating Conaisseur should never break your installation.","title":"Supported versions"},{"location":"SECURITY/#known-vulnerabilities","text":"Title Affected versions Fixed version Description initContainers not validated \u2264 1.3.0 1.3.1 Prior to version 1.3.1 Connaisseur did not validate initContainers which allowed deploying unverified images to the cluster.","title":"Known vulnerabilities"},{"location":"SECURITY/#reporting-a-vulnerability","text":"We are very grateful for reports on vulnerabilities discovered in the project, specifically as it is intended to increase security for the community. We aim to investigate and fix these as soon as possible. Please submit vulnerabilities to connaisseur@securesystems.dev .","title":"Reporting a vulnerability"},{"location":"basics/","text":"Basics \u2693\ufe0e In the following, we aim to lay the foundation on Connaisseur's core concepts, how to configure and administer it. Admission control, validators and image policy \u2693\ufe0e Connaisseur works as a mutating admission controller . It intercepts all CREATE and UPDATE resource requests for Pods , Deployments , ReplicationControllers , ReplicaSets , DaemonSets , StatefulSets , Jobs , and CronJobs and extracts all image references for validation. Per default, Connaisseur uses automatic child approval by which the child of a Kubernetes resource is automatically admitted without re-verification of the signature in order to avoid duplicate validation and handle inconsistencies with the image policy. Essentially, this is done since an image that is deployed as part of an already deployed object (e.g. a Pod deployed as a child of a Deployment) has already been validated and potentially mutated during admission of the parent. More information and configuration options can be found in the feature documentation for automatic child approval . Validation itself relies on two core concepts: image policy and validators. A validator is a set of configuration options required for validation like the type of signature, public key to use for verification, path to signature data, or authentication. The image policy defines a set of rules which maps different images to those validators. This is done via glob matching of the image name which for example allows to use different validators for different registries, repositories, images or even tags. This is specifically useful when using public or external images from other entities like Docker's official images or different keys in a more complex development team. Note : Typically, the public key of a known entity is used to validate the signature over an image's content in order to ensure integrity and provenance. However, other ways to implement such trust pinning exist and as a consequence we refer to all types of trust anchors in a generalized form as trust roots . Using Connaisseur \u2693\ufe0e Some general administration tasks like deployment or uninstallation when using Connaisseur are described in this section. Requirements \u2693\ufe0e Using Connaisseur requires a Kubernetes cluster, Helm and, if installing from source, Git to be installed and set up. Get the code/chart \u2693\ufe0e Download the Connaisseur resources required for installation either by cloning the source code via Git or directly add the chart repository via Helm. Clone via Git The Connaisseur source code can be cloned directly from GitHub and includes the application and Helm charts in a single repository: git clone https://github.com/sse-secure-systems/connaisseur.git Add via Helm The Helm chart can be added by: helm repo add connaisseur https://sse-secure-systems.github.io/connaisseur/charts Configure \u2693\ufe0e The configuration of Connaisseur is completely done in the helm/values.yaml . The upper deployment section offers some general Kubernetes typical configurations like image version or resources. Noteworthy configurations are: deployment.failurePolicy : Failure policy allows configuration whether the mutating admission webhook should fail closed ( Fail , default ) or open ( Ignore ) should the Connaisseur service become unavailable. While Connaisseur is configured to be secure by default, setting the failure policy to Ignore allows to prioritize cluster access 1 . deployment.reinvocationPolicy : Reinvocation Policy defines whether Connaisseur is called again as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call ( IfNeeded ) or not ( Never , default ). Note that if Connaisseur is invoked a second time, the policy to be applied might change in between 2 . Make sure, your Connaisseur policies are set up to handle multiple mutations of the image originally specified in the manifest, e.g. my.private.registry/image:1.0.0 and my.private.registry/image@sha256:<hash-of-1.0.0-image> . deployment.securityContext : Connaisseur ships with secure defaults. However, some keys are not supported by all versions or flavors of Kubernetes and might need adjustment 3 . This is mentioned in the comments to the best of our knowledge. deployment.podSecurityPolicy : Some clusters require a PSP. A secure default PSP for Connaisseur is available. The actual configuration consists of the validators and image policy sections. These are described in detail below and for initials steps it is instructive to follow the getting started guide . Other features are described on the respective pages . Connaisseur ships with a pre-configuration that does not need any adjustments for testing. However, validating your own images requires additional configuration. Deploy \u2693\ufe0e Install Connaisseur via Helm: Cloned via Git Install Connaisseur by using the Helm template definition files in the helm directory: helm install connaisseur helm --atomic --create-namespace --namespace connaisseur Added via Helm Install Connaisseur using the default configuration from the chart repository: helm install connaisseur connaisseur/connaisseur --atomic --create-namespace --namespace connaisseur To customize Connaisseur, craft a values.yaml according to your needs and apply: helm install connaisseur connaisseur/connaisseur --atomic --create-namespace --namespace connaisseur -f values.yaml This deploys Connaisseur to its own namespace called connaisseur . The installation itself may take a moment, as the installation order of the Connaisseur components is critical: The admission webhook for intercepting requests can only be applied when the Connaisseur pods are up and ready to receive admission requests. Check \u2693\ufe0e Once everything is installed, you can check whether all the pods are up by running kubectl get all -n connaisseur : kubectl get all -n connaisseur > NAME READY STATUS RESTARTS AGE > pod/connaisseur-deployment-78d8975596-42tkw 1 /1 Running 0 22s > pod/connaisseur-deployment-78d8975596-5c4c6 1 /1 Running 0 22s > pod/connaisseur-deployment-78d8975596-kvrj6 1 /1 Running 0 22s > > NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE > service/connaisseur-svc ClusterIP 10 .108.220.34 <none> 443 /TCP 22s > > NAME READY UP-TO-DATE AVAILABLE AGE > deployment.apps/connaisseur-deployment 3 /3 3 3 22s > > NAME DESIRED CURRENT READY AGE > replicaset.apps/connaisseur-deployment-78d8975596 3 3 3 22s Use \u2693\ufe0e To use Connaisseur, simply try running some images or apply a deployment. In case you use the pre-configuration, you could for example run the following commands: kubectl run demo --image = docker.io/securesystemsengineering/testimage:unsigned > Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request ( ... ) . kubectl run hello-world --image = docker.io/hello-world > pod/hello-world created Upgrade \u2693\ufe0e A running Connaisseur instance can be updated by a Helm upgrade of the current release: Cloned via Git Adjust configuration in helm/values.yaml as required and upgrade via: helm upgrade connaisseur helm -n connaisseur --wait Added via Helm Adjust your local configuration file (e.g. values.yaml ) as required and upgrade via: helm upgrade connaisseur connaisseur/connaisseur -n connaisseur --wait -f values.yaml Delete \u2693\ufe0e Just like for installation, Helm can also be used to delete Connaisseur from your cluster: helm uninstall connaisseur -n connaisseur In case uninstallation fails or problems occur during subsequent installation, you can manually remove all resources: kubectl delete all,mutatingwebhookconfigurations,clusterroles,clusterrolebindings,configmaps,imagepolicies,secrets,serviceaccounts,customresourcedefinitions -lapp.kubernetes.io/instance = connaisseur kubectl delete namespaces connaisseur Connaisseur for example also installs a CutstomResourceDefinition imagepolicies.connaisseur.policy that validates its configuration. In case of major releases, the configuration structure might change which can cause installation to fail and you might have to delete it manually. Makefile \u2693\ufe0e Alternatively to using Helm, you can also run the Makefile for installing, deleting and more. Here the available commands: make install -- Install Connaisseur. make upgrade -- Upgrade Connaisseur. make uninstall -- Uninstall Connaisseur and delete the namespace. make annihilate -- Remove all Connaisseur Kubernetes resources including its namespace. This command is usually helpful, should the normal make uninstall not work. make docker -- Builds the connaisseur container image. Detailed configuration \u2693\ufe0e All configuration is done in the helm/values.yaml . The configuration of features is only described in the corresponding section . Validators \u2693\ufe0e The validators are configured in the validators field, which defines a list of validator objects. A validator defines what kind of signatures are to be expected, how signatures are to be validated, against which trust root and how to access the signature data. For example, images might be signed with Docker Content Trust and reside in a private registry. Thus the validator would need to specify notaryv1 as type, the notary host and the required credentials. The specific validator type should be chosen based on the use case. A list of supported validator types can be found here . All validators share a similar structure for configuration. For specifics and additional options, please review the dedicated page of the validator type. There is a special behavior, when a validator or one of the trust roots is named default . In this case, should an image policy rule not specify a validator or trust root to use, the one named default will be used instead. This also means there can only be one validator named default and for the trust roots, there can only be one called default within a single validator. Connaisseur comes with a few validators pre-configured including one for Docker's official images. The pre-configured validators can be removed. However to avoid Connaisseur failing its own validation in case you remove the securesystemsengineering_official key, make sure to also exclude Connaisseur from validation either via the static allow validator or namespaced validation . The special case of static validators used to simply allow or deny images without verification is described below. Configuration options \u2693\ufe0e .validators[*] in helm/values.yaml supports the following keys: Key Default Required Description name - Name of the validator, which is referenced in the image policy. It must consist of lower case alphanumeric characters or '-'. If the name is default , it will be used if no validator is specified. type - Type of the validator, e.g. notaryv1 or cosign , which is dependent on the signing solution in use . trust_roots - List of trust anchors to validate the signatures against. In practice, this is typically a list of public keys. trust_roots[*].name - Name of the trust anchor, which is referenced in the image policy. If the name is default , it will be used if no key is specified. trust_roots[*].key - Value of the trust anchor, most commonly a PEM encoded public key. auth - Credentials that should be used in case authentication is required for validation. Details are provided on validator-specific pages. Further configuration fields specific to the validator type are described in the respective section . Example \u2693\ufe0e validators : - name : default type : notaryv1 host : notary.docker.io trust_roots : - name : default key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q== -----END PUBLIC KEY----- auth : username : superuser password : lookatmeimjumping - name : myvalidator type : cosign trust_roots : - name : mykey key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEIFXO1w6oj0oI2Fk9SiaNJRKTiO9d ksm6hFczQAq+FDdw0istEdCwcHO61O/0bV+LC8jqFoomA28cT+py6FcSYw== -----END PUBLIC KEY----- Static validators \u2693\ufe0e Static validators are a special type of validator that does not validate any signatures. Depending on the approve value being true or false , they either allow or deny all images for which they are specified as validator. This for example allows to implement an allowlist or denylist . Configuration options \u2693\ufe0e Key Default Required Description name - Name of the validator, which will be used to reference it in the image policy. type - static ; value has to be static for a static validator. approve - true or false to admit or deny all images. Example \u2693\ufe0e validators : - name : allow type : static approve : true - name : deny type : static approve : false Image policy \u2693\ufe0e The image policy is defined in the policy field and acts as a list of rule objects to determine which image should be validated by which validator (and potentially some further configurations). For each image in the admission request, only a single rule in the image policy will apply: the one with the most specific matching pattern field. This is determined by the following algorithm: A given image is matched against all rule patterns. All matching patterns are compared to one another to determine the most specific one (see below). Only two patterns are compared at a time; the more specific one then is compared to the next one and so forth. Specificity is determined as follows: Patterns are split into components (delimited by \"/\"). The pattern that has a higher number of components wins (is considered more specific). Should the two patterns that are being compared have equal number of components, the longest common prefix between each pattern component and corresponding image component are calculated (for this purpose, image identifiers are also split into components). The pattern with the longest common prefix in one component, starting from the leftmost, wins. Should all longest common prefixes of all components between the two compared patterns be equal, the pattern with a longer component, starting from the leftmost, wins. The rule whose pattern has won all comparisons is considered the most specific rule. Return the most specific rule. Should an image match none of the rules, Connaisseur will deny the request and raise an error. This deny per default behavior can be changed via a catch-all rule *:* and for example using the static allow validator in order to admit otherwise unmatched images. In order to perform the actual validation, Connaisseur will call the validator specified in the selected rule and pass the image name and potential further configuration to it. The reference to validator and exact trust root is resolved in the following way: The validator with name ( validators[*].name ) equal to the validator value in the selected rule is chosen. If no validator is specified, the validator with name default is used if it exists. Of that validator, the trust root (e.g. public key) is chosen which name ( .validators.trust_roots[*].name ) matches the policies trust root string ( with.trust_root ). If no trust root is specified, the trust root with name default is used if it exists. Let's review the pattern and validator matching at a minimal example. We consider the following validator and policy configuration (most fields have been omitted for clarity): validators : - name : default # validator 1 trust_roots : - name : default # key 1 key : | ... - name : myvalidator # validator 2 trust_roots : - name : default # key 2 key : | ... - name : mykey # key 3 key : | ... policy : - pattern : \"*:*\" # rule 1 - pattern : \"docker.io/myrepo/*:*\" # rule 2 validator : myvalidator - pattern : \"docker.io/myrepo/myimg:*\" # rule 3 validator : myvalidator with : trust_root : mykey Now deploying the following images we would get the matchings: docker.io/superrepo/myimg:v1 \u2192 rule 1 \u2192 validator 1 ( key 1 ): The image matches none of the more specific rules 2 and 3, so rule 1 is applied. As that rule neither specifies a validator nor a trust root, the default validator (validator 1) with trust root default (key 1) is used. docker.io/myrepo/superimg:v1 \u2192 rule 2 \u2192 validator 2 ( key 2 ): The image only matches rules 1 and 2 and thus 2 is chosen as it is more specific. That rule specifies myvalidator as validator but no trust root and thus validator 2 with trust root default (key 2) is used. docker.io/myrepo/myimg:v1 \u2192 rule 3 \u2192 validator 2 ( key 3 ): The image matches all rules and thus 3 is chosen as it is most specific. The rule specifies myvalidator as validator with mykey as trust root and thus validator 2 with key 2 is used. Connaisseur ships with a few rules pre-configured. There is two rules that should remain intact in some form in order to not brick the Kubernetes cluster: k8s.gcr.io : This is an allow rule for Kubernetes images ( k8s.gcr.io ) in order to not block cluster relevant images. These cannot be validated currently. docker.io/securesystemsengineering/*:* : This rule is used to validate the Connaisseur images with the respective validator and removal can break the Connaisseur deployment. It is, however, possible to use the static allow validator. Configuration options \u2693\ufe0e .policy[*] in helm/values.yaml supports the following keys: Key Default Required Description pattern - Globbing pattern to match an image name against. validator default Name of a validator in the validators list. If not provided, the validator with name default is used if it exists. with - Additional parameters to use for a validator. See more specifics in validator section . with.trust_root default Name of a trust root, which is specified within the referenced validator. If not provided, the trust root with name default is used if it exists. Example \u2693\ufe0e policy : - pattern : \"*:*\" - pattern : \"docker.io/myrepo/*:*\" validator : myvalidator with : trust_root : mykey - pattern : \"docker.io/myrepo/deniedimage:*\" validator : deny - pattern : \"docker.io/myrepo/allowedimage:v*\" validator : allow Common examples \u2693\ufe0e Let's look at some useful examples for the validators and policy configuration. These can serve as a first template beyond the pre-configuration or might just be instructive to understand validators and policies. We assume your repository is docker.io/myrepo and a public key has been created. In case this repository is private, authentication would have to be added to the respective validator for example via: auth : secret_name : k8ssecret The Kubernetes secret would have to be created separately according to the validator documentation. Case: Only validate own images and deny all others \u2693\ufe0e This is likely the most common case in simple settings by which only self-built images are used and validated against your own public key: validators : - name : allow type : static approve : true - name : default type : notaryv1 # or e.g. 'cosign' host : notary.docker.io # only required in case of notaryv1 trust_roots : - name : default key : | # your public key below -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- - name : dockerhub_basics type : notaryv1 host : notary.docker.io trust_roots : - name : securesystemsengineering_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q== -----END PUBLIC KEY----- policy : - pattern : \"*:*\" - pattern : \"k8s.gcr.io/*:*\" validator : allow - pattern : \"docker.io/securesystemsengineering/*:*\" validator : dockerhub_basics with : trust_root : securesystemsengineering_official Case: Only validate own images and deny all others (faster) \u2693\ufe0e This configuration achieves the same as the one above, but is faster as trust data only needs to be requested for images in your repository: validators : - name : allow type : static approve : true - name : deny type : static approve : false - name : default type : notaryv1 # or e.g. 'cosign' host : notary.docker.io # only required in case of notaryv1 trust_roots : - name : default key : | # your public key below -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- - name : dockerhub_basics type : notaryv1 host : notary.docker.io trust_roots : - name : securesystemsengineering_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q== -----END PUBLIC KEY----- policy : - pattern : \"*:*\" validator : deny - pattern : \"docker.io/myrepo/*:*\" - pattern : \"k8s.gcr.io/*:*\" validator : allow - pattern : \"docker.io/securesystemsengineering/*:*\" validator : dockerhub_basics with : trust_root : securesystemsengineering_official The *:* rule could also have been omitted as Connaisseur denies unmatched images. However, explicit is better than implicit. Case: Only validate Docker Hub official images and deny all others \u2693\ufe0e In case only validated Docker Hub official images should be admitted to the cluster: validators : - name : allow type : static approve : true - name : deny type : static approve : false - name : dockerhub_basics type : notaryv1 host : notary.docker.io trust_roots : - name : docker_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEOXYta5TgdCwXTCnLU09W5T4M4r9f QQrqJuADP6U7g5r9ICgPSmZuRHP/1AYUfOQW3baveKsT969EfELKj1lfCA== -----END PUBLIC KEY----- - name : securesystemsengineering_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q== -----END PUBLIC KEY----- policy : - pattern : \"*:*\" validator : deny - pattern : \"docker.io/library/*:*\" validator : dockerhub_basics with : trust_root : docker_official - pattern : \"k8s.gcr.io/*:*\" validator : allow - pattern : \"docker.io/securesystemsengineering/*:*\" validator : dockerhub_basics with : trust_root : securesystemsengineering_official Case: Only validate Docker Hub official images and allow all others \u2693\ufe0e In case only Docker Hub official images should be validated while all others are simply admitted: validators : - name : allow type : static approve : true - name : deny type : static approve : false - name : dockerhub_basics type : notaryv1 host : notary.docker.io trust_roots : - name : docker_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEOXYta5TgdCwXTCnLU09W5T4M4r9f QQrqJuADP6U7g5r9ICgPSmZuRHP/1AYUfOQW3baveKsT969EfELKj1lfCA== -----END PUBLIC KEY----- - name : securesystemsengineering_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q== -----END PUBLIC KEY----- policy : - pattern : \"*:*\" validator : allow - pattern : \"docker.io/library/*:*\" validator : dockerhub_basics with : trust_root : docker_official - pattern : \"k8s.gcr.io/*:*\" validator : allow - pattern : \"docker.io/securesystemsengineering/*:*\" validator : dockerhub_basics with : trust_root : securesystemsengineering_official Case: Directly admit own images and deny all others \u2693\ufe0e As a matter of fact, Connaisseur can also be used to restrict the allowed registries and repositories without signature validation: validators : - name : allow type : static approve : true - name : deny type : static approve : false policy : - pattern : \"*:*\" validator : deny - pattern : \"docker.io/myrepo/*:*\" validator : allow - pattern : \"k8s.gcr.io/*:*\" validator : allow - pattern : \"docker.io/securesystemsengineering/*:*\" validator : allow This is not to be confused with the detection mode feature: In detection mode, Conaisseur service admits all requests to the cluster independent of the validation result while the failure policy only takes effect when the service itself becomes unavailable. \u21a9 During the first mutation, Connaisseur converts the image tag to its digests. Read more in the overview of Connaisseur \u21a9 In those cases, consider using security annotations via deployment.annotations or pod security policies deployment.podSecurityPolicy if available. \u21a9","title":"Basics"},{"location":"basics/#basics","text":"In the following, we aim to lay the foundation on Connaisseur's core concepts, how to configure and administer it.","title":"Basics"},{"location":"basics/#admission-control-validators-and-image-policy","text":"Connaisseur works as a mutating admission controller . It intercepts all CREATE and UPDATE resource requests for Pods , Deployments , ReplicationControllers , ReplicaSets , DaemonSets , StatefulSets , Jobs , and CronJobs and extracts all image references for validation. Per default, Connaisseur uses automatic child approval by which the child of a Kubernetes resource is automatically admitted without re-verification of the signature in order to avoid duplicate validation and handle inconsistencies with the image policy. Essentially, this is done since an image that is deployed as part of an already deployed object (e.g. a Pod deployed as a child of a Deployment) has already been validated and potentially mutated during admission of the parent. More information and configuration options can be found in the feature documentation for automatic child approval . Validation itself relies on two core concepts: image policy and validators. A validator is a set of configuration options required for validation like the type of signature, public key to use for verification, path to signature data, or authentication. The image policy defines a set of rules which maps different images to those validators. This is done via glob matching of the image name which for example allows to use different validators for different registries, repositories, images or even tags. This is specifically useful when using public or external images from other entities like Docker's official images or different keys in a more complex development team. Note : Typically, the public key of a known entity is used to validate the signature over an image's content in order to ensure integrity and provenance. However, other ways to implement such trust pinning exist and as a consequence we refer to all types of trust anchors in a generalized form as trust roots .","title":"Admission control, validators and image policy"},{"location":"basics/#using-connaisseur","text":"Some general administration tasks like deployment or uninstallation when using Connaisseur are described in this section.","title":"Using Connaisseur"},{"location":"basics/#requirements","text":"Using Connaisseur requires a Kubernetes cluster, Helm and, if installing from source, Git to be installed and set up.","title":"Requirements"},{"location":"basics/#get-the-codechart","text":"Download the Connaisseur resources required for installation either by cloning the source code via Git or directly add the chart repository via Helm. Clone via Git The Connaisseur source code can be cloned directly from GitHub and includes the application and Helm charts in a single repository: git clone https://github.com/sse-secure-systems/connaisseur.git Add via Helm The Helm chart can be added by: helm repo add connaisseur https://sse-secure-systems.github.io/connaisseur/charts","title":"Get the code/chart"},{"location":"basics/#configure","text":"The configuration of Connaisseur is completely done in the helm/values.yaml . The upper deployment section offers some general Kubernetes typical configurations like image version or resources. Noteworthy configurations are: deployment.failurePolicy : Failure policy allows configuration whether the mutating admission webhook should fail closed ( Fail , default ) or open ( Ignore ) should the Connaisseur service become unavailable. While Connaisseur is configured to be secure by default, setting the failure policy to Ignore allows to prioritize cluster access 1 . deployment.reinvocationPolicy : Reinvocation Policy defines whether Connaisseur is called again as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call ( IfNeeded ) or not ( Never , default ). Note that if Connaisseur is invoked a second time, the policy to be applied might change in between 2 . Make sure, your Connaisseur policies are set up to handle multiple mutations of the image originally specified in the manifest, e.g. my.private.registry/image:1.0.0 and my.private.registry/image@sha256:<hash-of-1.0.0-image> . deployment.securityContext : Connaisseur ships with secure defaults. However, some keys are not supported by all versions or flavors of Kubernetes and might need adjustment 3 . This is mentioned in the comments to the best of our knowledge. deployment.podSecurityPolicy : Some clusters require a PSP. A secure default PSP for Connaisseur is available. The actual configuration consists of the validators and image policy sections. These are described in detail below and for initials steps it is instructive to follow the getting started guide . Other features are described on the respective pages . Connaisseur ships with a pre-configuration that does not need any adjustments for testing. However, validating your own images requires additional configuration.","title":"Configure"},{"location":"basics/#deploy","text":"Install Connaisseur via Helm: Cloned via Git Install Connaisseur by using the Helm template definition files in the helm directory: helm install connaisseur helm --atomic --create-namespace --namespace connaisseur Added via Helm Install Connaisseur using the default configuration from the chart repository: helm install connaisseur connaisseur/connaisseur --atomic --create-namespace --namespace connaisseur To customize Connaisseur, craft a values.yaml according to your needs and apply: helm install connaisseur connaisseur/connaisseur --atomic --create-namespace --namespace connaisseur -f values.yaml This deploys Connaisseur to its own namespace called connaisseur . The installation itself may take a moment, as the installation order of the Connaisseur components is critical: The admission webhook for intercepting requests can only be applied when the Connaisseur pods are up and ready to receive admission requests.","title":"Deploy"},{"location":"basics/#check","text":"Once everything is installed, you can check whether all the pods are up by running kubectl get all -n connaisseur : kubectl get all -n connaisseur > NAME READY STATUS RESTARTS AGE > pod/connaisseur-deployment-78d8975596-42tkw 1 /1 Running 0 22s > pod/connaisseur-deployment-78d8975596-5c4c6 1 /1 Running 0 22s > pod/connaisseur-deployment-78d8975596-kvrj6 1 /1 Running 0 22s > > NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE > service/connaisseur-svc ClusterIP 10 .108.220.34 <none> 443 /TCP 22s > > NAME READY UP-TO-DATE AVAILABLE AGE > deployment.apps/connaisseur-deployment 3 /3 3 3 22s > > NAME DESIRED CURRENT READY AGE > replicaset.apps/connaisseur-deployment-78d8975596 3 3 3 22s","title":"Check"},{"location":"basics/#use","text":"To use Connaisseur, simply try running some images or apply a deployment. In case you use the pre-configuration, you could for example run the following commands: kubectl run demo --image = docker.io/securesystemsengineering/testimage:unsigned > Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request ( ... ) . kubectl run hello-world --image = docker.io/hello-world > pod/hello-world created","title":"Use"},{"location":"basics/#upgrade","text":"A running Connaisseur instance can be updated by a Helm upgrade of the current release: Cloned via Git Adjust configuration in helm/values.yaml as required and upgrade via: helm upgrade connaisseur helm -n connaisseur --wait Added via Helm Adjust your local configuration file (e.g. values.yaml ) as required and upgrade via: helm upgrade connaisseur connaisseur/connaisseur -n connaisseur --wait -f values.yaml","title":"Upgrade"},{"location":"basics/#delete","text":"Just like for installation, Helm can also be used to delete Connaisseur from your cluster: helm uninstall connaisseur -n connaisseur In case uninstallation fails or problems occur during subsequent installation, you can manually remove all resources: kubectl delete all,mutatingwebhookconfigurations,clusterroles,clusterrolebindings,configmaps,imagepolicies,secrets,serviceaccounts,customresourcedefinitions -lapp.kubernetes.io/instance = connaisseur kubectl delete namespaces connaisseur Connaisseur for example also installs a CutstomResourceDefinition imagepolicies.connaisseur.policy that validates its configuration. In case of major releases, the configuration structure might change which can cause installation to fail and you might have to delete it manually.","title":"Delete"},{"location":"basics/#makefile","text":"Alternatively to using Helm, you can also run the Makefile for installing, deleting and more. Here the available commands: make install -- Install Connaisseur. make upgrade -- Upgrade Connaisseur. make uninstall -- Uninstall Connaisseur and delete the namespace. make annihilate -- Remove all Connaisseur Kubernetes resources including its namespace. This command is usually helpful, should the normal make uninstall not work. make docker -- Builds the connaisseur container image.","title":"Makefile"},{"location":"basics/#detailed-configuration","text":"All configuration is done in the helm/values.yaml . The configuration of features is only described in the corresponding section .","title":"Detailed configuration"},{"location":"basics/#validators","text":"The validators are configured in the validators field, which defines a list of validator objects. A validator defines what kind of signatures are to be expected, how signatures are to be validated, against which trust root and how to access the signature data. For example, images might be signed with Docker Content Trust and reside in a private registry. Thus the validator would need to specify notaryv1 as type, the notary host and the required credentials. The specific validator type should be chosen based on the use case. A list of supported validator types can be found here . All validators share a similar structure for configuration. For specifics and additional options, please review the dedicated page of the validator type. There is a special behavior, when a validator or one of the trust roots is named default . In this case, should an image policy rule not specify a validator or trust root to use, the one named default will be used instead. This also means there can only be one validator named default and for the trust roots, there can only be one called default within a single validator. Connaisseur comes with a few validators pre-configured including one for Docker's official images. The pre-configured validators can be removed. However to avoid Connaisseur failing its own validation in case you remove the securesystemsengineering_official key, make sure to also exclude Connaisseur from validation either via the static allow validator or namespaced validation . The special case of static validators used to simply allow or deny images without verification is described below.","title":"Validators"},{"location":"basics/#configuration-options","text":".validators[*] in helm/values.yaml supports the following keys: Key Default Required Description name - Name of the validator, which is referenced in the image policy. It must consist of lower case alphanumeric characters or '-'. If the name is default , it will be used if no validator is specified. type - Type of the validator, e.g. notaryv1 or cosign , which is dependent on the signing solution in use . trust_roots - List of trust anchors to validate the signatures against. In practice, this is typically a list of public keys. trust_roots[*].name - Name of the trust anchor, which is referenced in the image policy. If the name is default , it will be used if no key is specified. trust_roots[*].key - Value of the trust anchor, most commonly a PEM encoded public key. auth - Credentials that should be used in case authentication is required for validation. Details are provided on validator-specific pages. Further configuration fields specific to the validator type are described in the respective section .","title":"Configuration options"},{"location":"basics/#example","text":"validators : - name : default type : notaryv1 host : notary.docker.io trust_roots : - name : default key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q== -----END PUBLIC KEY----- auth : username : superuser password : lookatmeimjumping - name : myvalidator type : cosign trust_roots : - name : mykey key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEIFXO1w6oj0oI2Fk9SiaNJRKTiO9d ksm6hFczQAq+FDdw0istEdCwcHO61O/0bV+LC8jqFoomA28cT+py6FcSYw== -----END PUBLIC KEY-----","title":"Example"},{"location":"basics/#static-validators","text":"Static validators are a special type of validator that does not validate any signatures. Depending on the approve value being true or false , they either allow or deny all images for which they are specified as validator. This for example allows to implement an allowlist or denylist .","title":"Static validators"},{"location":"basics/#configuration-options_1","text":"Key Default Required Description name - Name of the validator, which will be used to reference it in the image policy. type - static ; value has to be static for a static validator. approve - true or false to admit or deny all images.","title":"Configuration options"},{"location":"basics/#example_1","text":"validators : - name : allow type : static approve : true - name : deny type : static approve : false","title":"Example"},{"location":"basics/#image-policy","text":"The image policy is defined in the policy field and acts as a list of rule objects to determine which image should be validated by which validator (and potentially some further configurations). For each image in the admission request, only a single rule in the image policy will apply: the one with the most specific matching pattern field. This is determined by the following algorithm: A given image is matched against all rule patterns. All matching patterns are compared to one another to determine the most specific one (see below). Only two patterns are compared at a time; the more specific one then is compared to the next one and so forth. Specificity is determined as follows: Patterns are split into components (delimited by \"/\"). The pattern that has a higher number of components wins (is considered more specific). Should the two patterns that are being compared have equal number of components, the longest common prefix between each pattern component and corresponding image component are calculated (for this purpose, image identifiers are also split into components). The pattern with the longest common prefix in one component, starting from the leftmost, wins. Should all longest common prefixes of all components between the two compared patterns be equal, the pattern with a longer component, starting from the leftmost, wins. The rule whose pattern has won all comparisons is considered the most specific rule. Return the most specific rule. Should an image match none of the rules, Connaisseur will deny the request and raise an error. This deny per default behavior can be changed via a catch-all rule *:* and for example using the static allow validator in order to admit otherwise unmatched images. In order to perform the actual validation, Connaisseur will call the validator specified in the selected rule and pass the image name and potential further configuration to it. The reference to validator and exact trust root is resolved in the following way: The validator with name ( validators[*].name ) equal to the validator value in the selected rule is chosen. If no validator is specified, the validator with name default is used if it exists. Of that validator, the trust root (e.g. public key) is chosen which name ( .validators.trust_roots[*].name ) matches the policies trust root string ( with.trust_root ). If no trust root is specified, the trust root with name default is used if it exists. Let's review the pattern and validator matching at a minimal example. We consider the following validator and policy configuration (most fields have been omitted for clarity): validators : - name : default # validator 1 trust_roots : - name : default # key 1 key : | ... - name : myvalidator # validator 2 trust_roots : - name : default # key 2 key : | ... - name : mykey # key 3 key : | ... policy : - pattern : \"*:*\" # rule 1 - pattern : \"docker.io/myrepo/*:*\" # rule 2 validator : myvalidator - pattern : \"docker.io/myrepo/myimg:*\" # rule 3 validator : myvalidator with : trust_root : mykey Now deploying the following images we would get the matchings: docker.io/superrepo/myimg:v1 \u2192 rule 1 \u2192 validator 1 ( key 1 ): The image matches none of the more specific rules 2 and 3, so rule 1 is applied. As that rule neither specifies a validator nor a trust root, the default validator (validator 1) with trust root default (key 1) is used. docker.io/myrepo/superimg:v1 \u2192 rule 2 \u2192 validator 2 ( key 2 ): The image only matches rules 1 and 2 and thus 2 is chosen as it is more specific. That rule specifies myvalidator as validator but no trust root and thus validator 2 with trust root default (key 2) is used. docker.io/myrepo/myimg:v1 \u2192 rule 3 \u2192 validator 2 ( key 3 ): The image matches all rules and thus 3 is chosen as it is most specific. The rule specifies myvalidator as validator with mykey as trust root and thus validator 2 with key 2 is used. Connaisseur ships with a few rules pre-configured. There is two rules that should remain intact in some form in order to not brick the Kubernetes cluster: k8s.gcr.io : This is an allow rule for Kubernetes images ( k8s.gcr.io ) in order to not block cluster relevant images. These cannot be validated currently. docker.io/securesystemsengineering/*:* : This rule is used to validate the Connaisseur images with the respective validator and removal can break the Connaisseur deployment. It is, however, possible to use the static allow validator.","title":"Image policy"},{"location":"basics/#configuration-options_2","text":".policy[*] in helm/values.yaml supports the following keys: Key Default Required Description pattern - Globbing pattern to match an image name against. validator default Name of a validator in the validators list. If not provided, the validator with name default is used if it exists. with - Additional parameters to use for a validator. See more specifics in validator section . with.trust_root default Name of a trust root, which is specified within the referenced validator. If not provided, the trust root with name default is used if it exists.","title":"Configuration options"},{"location":"basics/#example_2","text":"policy : - pattern : \"*:*\" - pattern : \"docker.io/myrepo/*:*\" validator : myvalidator with : trust_root : mykey - pattern : \"docker.io/myrepo/deniedimage:*\" validator : deny - pattern : \"docker.io/myrepo/allowedimage:v*\" validator : allow","title":"Example"},{"location":"basics/#common-examples","text":"Let's look at some useful examples for the validators and policy configuration. These can serve as a first template beyond the pre-configuration or might just be instructive to understand validators and policies. We assume your repository is docker.io/myrepo and a public key has been created. In case this repository is private, authentication would have to be added to the respective validator for example via: auth : secret_name : k8ssecret The Kubernetes secret would have to be created separately according to the validator documentation.","title":"Common examples"},{"location":"basics/#case-only-validate-own-images-and-deny-all-others","text":"This is likely the most common case in simple settings by which only self-built images are used and validated against your own public key: validators : - name : allow type : static approve : true - name : default type : notaryv1 # or e.g. 'cosign' host : notary.docker.io # only required in case of notaryv1 trust_roots : - name : default key : | # your public key below -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- - name : dockerhub_basics type : notaryv1 host : notary.docker.io trust_roots : - name : securesystemsengineering_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q== -----END PUBLIC KEY----- policy : - pattern : \"*:*\" - pattern : \"k8s.gcr.io/*:*\" validator : allow - pattern : \"docker.io/securesystemsengineering/*:*\" validator : dockerhub_basics with : trust_root : securesystemsengineering_official","title":"Case: Only validate own images and deny all others"},{"location":"basics/#case-only-validate-own-images-and-deny-all-others-faster","text":"This configuration achieves the same as the one above, but is faster as trust data only needs to be requested for images in your repository: validators : - name : allow type : static approve : true - name : deny type : static approve : false - name : default type : notaryv1 # or e.g. 'cosign' host : notary.docker.io # only required in case of notaryv1 trust_roots : - name : default key : | # your public key below -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- - name : dockerhub_basics type : notaryv1 host : notary.docker.io trust_roots : - name : securesystemsengineering_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q== -----END PUBLIC KEY----- policy : - pattern : \"*:*\" validator : deny - pattern : \"docker.io/myrepo/*:*\" - pattern : \"k8s.gcr.io/*:*\" validator : allow - pattern : \"docker.io/securesystemsengineering/*:*\" validator : dockerhub_basics with : trust_root : securesystemsengineering_official The *:* rule could also have been omitted as Connaisseur denies unmatched images. However, explicit is better than implicit.","title":"Case: Only validate own images and deny all others (faster)"},{"location":"basics/#case-only-validate-docker-hub-official-images-and-deny-all-others","text":"In case only validated Docker Hub official images should be admitted to the cluster: validators : - name : allow type : static approve : true - name : deny type : static approve : false - name : dockerhub_basics type : notaryv1 host : notary.docker.io trust_roots : - name : docker_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEOXYta5TgdCwXTCnLU09W5T4M4r9f QQrqJuADP6U7g5r9ICgPSmZuRHP/1AYUfOQW3baveKsT969EfELKj1lfCA== -----END PUBLIC KEY----- - name : securesystemsengineering_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q== -----END PUBLIC KEY----- policy : - pattern : \"*:*\" validator : deny - pattern : \"docker.io/library/*:*\" validator : dockerhub_basics with : trust_root : docker_official - pattern : \"k8s.gcr.io/*:*\" validator : allow - pattern : \"docker.io/securesystemsengineering/*:*\" validator : dockerhub_basics with : trust_root : securesystemsengineering_official","title":"Case: Only validate Docker Hub official images and deny all others"},{"location":"basics/#case-only-validate-docker-hub-official-images-and-allow-all-others","text":"In case only Docker Hub official images should be validated while all others are simply admitted: validators : - name : allow type : static approve : true - name : deny type : static approve : false - name : dockerhub_basics type : notaryv1 host : notary.docker.io trust_roots : - name : docker_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEOXYta5TgdCwXTCnLU09W5T4M4r9f QQrqJuADP6U7g5r9ICgPSmZuRHP/1AYUfOQW3baveKsT969EfELKj1lfCA== -----END PUBLIC KEY----- - name : securesystemsengineering_official key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q== -----END PUBLIC KEY----- policy : - pattern : \"*:*\" validator : allow - pattern : \"docker.io/library/*:*\" validator : dockerhub_basics with : trust_root : docker_official - pattern : \"k8s.gcr.io/*:*\" validator : allow - pattern : \"docker.io/securesystemsengineering/*:*\" validator : dockerhub_basics with : trust_root : securesystemsengineering_official","title":"Case: Only validate Docker Hub official images and allow all others"},{"location":"basics/#case-directly-admit-own-images-and-deny-all-others","text":"As a matter of fact, Connaisseur can also be used to restrict the allowed registries and repositories without signature validation: validators : - name : allow type : static approve : true - name : deny type : static approve : false policy : - pattern : \"*:*\" validator : deny - pattern : \"docker.io/myrepo/*:*\" validator : allow - pattern : \"k8s.gcr.io/*:*\" validator : allow - pattern : \"docker.io/securesystemsengineering/*:*\" validator : allow This is not to be confused with the detection mode feature: In detection mode, Conaisseur service admits all requests to the cluster independent of the validation result while the failure policy only takes effect when the service itself becomes unavailable. \u21a9 During the first mutation, Connaisseur converts the image tag to its digests. Read more in the overview of Connaisseur \u21a9 In those cases, consider using security annotations via deployment.annotations or pod security policies deployment.podSecurityPolicy if available. \u21a9","title":"Case: Directly admit own images and deny all others"},{"location":"getting_started/","text":"Getting Started \u2693\ufe0e This guide offers a simple default configuration for setting up Connaisseur using public infrastructure and verifying your first self-signed images. You will learn how to: Create signing key pairs Configure Connaisseur Deploy Connaisseur Test Connaisseur (and sign images) Cleanup In the tutorial, you can choose to use either Notary (V1) via Docker Content Trust (DCT) or Cosign from the sigstore project as a signing solution referred to as DCT and Cosign from here on. Furthermore we will work with public images on Docker Hub as a container registry and a Kubernetes test cluster which might for example be MicroK8s or minikube for local setups. However, feel free to bring your own solutions for registry or cluster and check out our notes on compatibility . In general, Connaisseur can be fully configured via helm/values.yaml , so feel free to take a look and try for yourself. For more advanced usage in more complex cases (e.g. authentication, multiple registries, signers, validators, additional features), we strongly advise to review the following pages: Basics : understanding, configuring and using Connaisseur (e.g. image policy and validators) Validators : applying different signature solutions and specific configurations Features : using additional features (e.g. alerting) In case you need help, feel free to reach out via GitHub Discussions Note : As more than only public keys can be used to validate integrity and provenance of an image, we refer to these trust anchors in a generalized form as trust roots . Requirements \u2693\ufe0e You should have a Kubernetes test cluster running. Furthermore, docker , git , helm and kubectl should be installed and usable, i.e. having run docker login and switched to the appropriate kubectl context. Create signing key pairs \u2693\ufe0e Before getting started with Connaisseur, we need to create our signing key pair. This obviously depends on the signing solution. Here, we will walk you through it for DCT and Cosign. In case you have previously worked with Docker Content Trust or Cosign before and already possess key pairs, you can skip this step (how to retrieve a previously created DCT key is described here ). Otherwise, pick your preferred signing solution below. In case you are uncertain which solution to go with, you might be better off to start with DCT, as it comes packaged with docker . Cosign on the other hand is somewhat more straightforward to use. Docker Content Trust General usage of DCT is described in the docker documentation . Detailed information on all configuration options for Connaisseur is provided in the Notary (V1) validator section . For now, we just need to generate a public-private root key pair via: docker trust key generate root You will be prompted for a password, the private key is automatically imported and a root.pub file is created in your current folder that contains your public key which should look similar to: -----BEGIN PUBLIC KEY----- role: root MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELDzXwqie/P66R3gVpFDWMhxOyol5 YWD/KWnAaEIcJVTYUR+21NJSZz0yL7KLGrv50H9kHai5WWVsVykOZNoZYQ == -----END PUBLIC KEY----- We will only need the actual base64 encoded part of the key later. Cosign Usage of Cosign is very well described in the docs . You can download Cosign from its GitHub repository . Detailed information on all configuration options for Connaisseur is provided in the Cosign validator section . For now, we just need to generate a key pair via: cosign generate-key-pair You will be prompted to set a password, after which a private ( cosign.key ) and public ( cosign.pub ) key are created. In the next step, we will need the public key that should look similar to: -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA == -----END PUBLIC KEY----- Configure Connaisseur \u2693\ufe0e Now, we will need to configure Connaisseur. Let's first clone the repository: git clone https://github.com/sse-secure-systems/connaisseur.git cd connaisseur Connaisseur is configured via helm/values.yaml , so we will start there. We need to set Connaisseur to use our previously created public key for validation. To do so, go to the .validators and find the default validator. We need to uncomment the trust root with name default and add our previously created public key. The result should look similar to this: Docker Content Trust # the `default` validator is used if no validator is specified in image policy - name : default type : notaryv1 # or other supported validator (e.g. \"cosign\") host : notary.docker.io # configure the notary server to be used trust_roots : # the `default` key is used if no key is specified in image policy - name : default key : | # enter your key below -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELDzXwqie/P66R3gVpFDWMhxOyol5 YWD/KWnAaEIcJVTYUR+21NJSZz0yL7KLGrv50H9kHai5WWVsVykOZNoZYQ== -----END PUBLIC KEY----- #cert: | # in case the trust data host is using a self-signed certificate # -----BEGIN CERTIFICATE----- # ... # -----END CERTIFICATE----- #auth: # credentials in case the trust data requires authentication # # either (preferred solution) # secret_name: mysecret # reference a k8s secret in the form required by the validator type (check the docs) # # or (only for notaryv1 validator) # username: myuser # password: mypass Cosign In addition for Cosign, the type needs to be set to cosign and the host is not required. # the `default` validator is used if no validator is specified in image policy - name : default type : cosign # or other supported validator (e.g. \"cosign\") trust_roots : # the `default` key is used if no key is specified in image policy - name : default key : | # enter your key below -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- #cert: | # in case the trust data host is using a self-signed certificate # -----BEGIN CERTIFICATE----- # ... # -----END CERTIFICATE----- #auth: # credentials in case the trust data requires authentication # # either (preferred solution) # secret_name: mysecret # reference a k8s secret in the form required by the validator type (check the docs) # # or (only for notaryv1 validator) # username: myuser # password: mypass We have now configured the validator default with trust root default . This will automatically be used if no validator and trust root is specified in the image policy ( .policy ). Per default, Connaisseur's image policy under .policy in helm/values.yaml comes with a pattern \"*:*\" that does not specify a validator or trust root and thus all images that do not meet any of the more specific pre-configured patterns will be verified using this validator. Consequently, we leave the rest untouched in this tutorial, but strongly recommend to read the basics to leverage the full potential of Connaisseur. Deploy Connaisseur \u2693\ufe0e So let's deploy Connaisseur to the cluster: helm install connaisseur helm --atomic --create-namespace --namespace connaisseur This can take a few minutes. You should be prompted something like: NAME: connaisseur LAST DEPLOYED: Fri Jul 9 20 :43:10 2021 NAMESPACE: connaisseur STATUS: deployed REVISION: 1 TEST SUITE: None Afterwards, we can check that Connaisseur is running via kubectl get all -n connaisseur which should look similar to: NAME READY STATUS RESTARTS AGE pod/connaisseur-deployment-6876c87c8c-txrkj 1 /1 Running 0 2m9s pod/connaisseur-deployment-6876c87c8c-wvr7q 1 /1 Running 0 2m9s pod/connaisseur-deployment-6876c87c8c-rnc7k 1 /1 Running 0 2m9s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE service/connaisseur-svc ClusterIP 10 .152.183.166 <none> 443 /TCP 2m10s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/connaisseur-deployment 3 /3 3 3 2m9s NAME DESIRED CURRENT READY AGE replicaset.apps/connaisseur-deployment-6876c87c8c 3 3 3 2m9s Test Connaisseur \u2693\ufe0e Now that we created our key pairs, configured and deployed Connaisseur, the next step is to test our setup. So let's create and push a test image. Feel free to use our simple test Dockerfile under tests/Dockerfile (make sure to set your own IMAGE name): # Typically, IMAGE=<REGISTRY>/<REPOSITORY-NAME>/<IMAGE-NAME>:<TAG>, like IMAGE = docker.io/securesystemsengineering/demo:test docker build -f tests/Dockerfile -t ${ IMAGE } . docker push ${ IMAGE } In case you have DCT turned on per default via environment variable DOCKER_CONTENT_TRUST=1 , you should disable for now during the docker push by adding the --disable-content-trust=true . If we try to deploy this unsigned image: kubectl run test --image = ${ IMAGE } Connaisseur denies the request due to lack of trust data or signed digest, e.g.: Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request: Unable to get root trust data from default. # or Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request: No trust data for image \"docker.io/securesystemsengineering/demo:test\" . # or Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request: could not find signed digest for image \"docker.io/securesystemsengineering/demo:test\" in trust data. So let's sign the image and try again. Docker Content Trust In DCT signing works via docker push using the --disable-content-trust flag: docker push ${ IMAGE } --disable-content-trust = false You will be prompted to provide your password and might be asked to set a new repository key. The trust data will then be pushed to the Docker Hub Notary server. Cosign For Cosign, we use the private key file from the first step: cosign sign -key cosign.key ${ IMAGE } You will be asked to enter your password after wich the signature data will be pushed to your repository. After successful signing, we try again: kubectl run test --image = ${ IMAGE } Now, the request is admitted to the cluster and Kubernetes returns: pod/test created You did it you just verified your first signed images in your Kuberenetes cluster Read on to learn how to fully configure Connaisseur Cleanup \u2693\ufe0e To uninstall Connaisseur, use: helm uninstall connaisseur --namespace connaisseur Uninstallation can take a moment as Connaisseur needs to validate the deletion webhook.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"This guide offers a simple default configuration for setting up Connaisseur using public infrastructure and verifying your first self-signed images. You will learn how to: Create signing key pairs Configure Connaisseur Deploy Connaisseur Test Connaisseur (and sign images) Cleanup In the tutorial, you can choose to use either Notary (V1) via Docker Content Trust (DCT) or Cosign from the sigstore project as a signing solution referred to as DCT and Cosign from here on. Furthermore we will work with public images on Docker Hub as a container registry and a Kubernetes test cluster which might for example be MicroK8s or minikube for local setups. However, feel free to bring your own solutions for registry or cluster and check out our notes on compatibility . In general, Connaisseur can be fully configured via helm/values.yaml , so feel free to take a look and try for yourself. For more advanced usage in more complex cases (e.g. authentication, multiple registries, signers, validators, additional features), we strongly advise to review the following pages: Basics : understanding, configuring and using Connaisseur (e.g. image policy and validators) Validators : applying different signature solutions and specific configurations Features : using additional features (e.g. alerting) In case you need help, feel free to reach out via GitHub Discussions Note : As more than only public keys can be used to validate integrity and provenance of an image, we refer to these trust anchors in a generalized form as trust roots .","title":"Getting Started"},{"location":"getting_started/#requirements","text":"You should have a Kubernetes test cluster running. Furthermore, docker , git , helm and kubectl should be installed and usable, i.e. having run docker login and switched to the appropriate kubectl context.","title":"Requirements"},{"location":"getting_started/#create-signing-key-pairs","text":"Before getting started with Connaisseur, we need to create our signing key pair. This obviously depends on the signing solution. Here, we will walk you through it for DCT and Cosign. In case you have previously worked with Docker Content Trust or Cosign before and already possess key pairs, you can skip this step (how to retrieve a previously created DCT key is described here ). Otherwise, pick your preferred signing solution below. In case you are uncertain which solution to go with, you might be better off to start with DCT, as it comes packaged with docker . Cosign on the other hand is somewhat more straightforward to use. Docker Content Trust General usage of DCT is described in the docker documentation . Detailed information on all configuration options for Connaisseur is provided in the Notary (V1) validator section . For now, we just need to generate a public-private root key pair via: docker trust key generate root You will be prompted for a password, the private key is automatically imported and a root.pub file is created in your current folder that contains your public key which should look similar to: -----BEGIN PUBLIC KEY----- role: root MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELDzXwqie/P66R3gVpFDWMhxOyol5 YWD/KWnAaEIcJVTYUR+21NJSZz0yL7KLGrv50H9kHai5WWVsVykOZNoZYQ == -----END PUBLIC KEY----- We will only need the actual base64 encoded part of the key later. Cosign Usage of Cosign is very well described in the docs . You can download Cosign from its GitHub repository . Detailed information on all configuration options for Connaisseur is provided in the Cosign validator section . For now, we just need to generate a key pair via: cosign generate-key-pair You will be prompted to set a password, after which a private ( cosign.key ) and public ( cosign.pub ) key are created. In the next step, we will need the public key that should look similar to: -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA == -----END PUBLIC KEY-----","title":"Create signing key pairs"},{"location":"getting_started/#configure-connaisseur","text":"Now, we will need to configure Connaisseur. Let's first clone the repository: git clone https://github.com/sse-secure-systems/connaisseur.git cd connaisseur Connaisseur is configured via helm/values.yaml , so we will start there. We need to set Connaisseur to use our previously created public key for validation. To do so, go to the .validators and find the default validator. We need to uncomment the trust root with name default and add our previously created public key. The result should look similar to this: Docker Content Trust # the `default` validator is used if no validator is specified in image policy - name : default type : notaryv1 # or other supported validator (e.g. \"cosign\") host : notary.docker.io # configure the notary server to be used trust_roots : # the `default` key is used if no key is specified in image policy - name : default key : | # enter your key below -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELDzXwqie/P66R3gVpFDWMhxOyol5 YWD/KWnAaEIcJVTYUR+21NJSZz0yL7KLGrv50H9kHai5WWVsVykOZNoZYQ== -----END PUBLIC KEY----- #cert: | # in case the trust data host is using a self-signed certificate # -----BEGIN CERTIFICATE----- # ... # -----END CERTIFICATE----- #auth: # credentials in case the trust data requires authentication # # either (preferred solution) # secret_name: mysecret # reference a k8s secret in the form required by the validator type (check the docs) # # or (only for notaryv1 validator) # username: myuser # password: mypass Cosign In addition for Cosign, the type needs to be set to cosign and the host is not required. # the `default` validator is used if no validator is specified in image policy - name : default type : cosign # or other supported validator (e.g. \"cosign\") trust_roots : # the `default` key is used if no key is specified in image policy - name : default key : | # enter your key below -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- #cert: | # in case the trust data host is using a self-signed certificate # -----BEGIN CERTIFICATE----- # ... # -----END CERTIFICATE----- #auth: # credentials in case the trust data requires authentication # # either (preferred solution) # secret_name: mysecret # reference a k8s secret in the form required by the validator type (check the docs) # # or (only for notaryv1 validator) # username: myuser # password: mypass We have now configured the validator default with trust root default . This will automatically be used if no validator and trust root is specified in the image policy ( .policy ). Per default, Connaisseur's image policy under .policy in helm/values.yaml comes with a pattern \"*:*\" that does not specify a validator or trust root and thus all images that do not meet any of the more specific pre-configured patterns will be verified using this validator. Consequently, we leave the rest untouched in this tutorial, but strongly recommend to read the basics to leverage the full potential of Connaisseur.","title":"Configure Connaisseur"},{"location":"getting_started/#deploy-connaisseur","text":"So let's deploy Connaisseur to the cluster: helm install connaisseur helm --atomic --create-namespace --namespace connaisseur This can take a few minutes. You should be prompted something like: NAME: connaisseur LAST DEPLOYED: Fri Jul 9 20 :43:10 2021 NAMESPACE: connaisseur STATUS: deployed REVISION: 1 TEST SUITE: None Afterwards, we can check that Connaisseur is running via kubectl get all -n connaisseur which should look similar to: NAME READY STATUS RESTARTS AGE pod/connaisseur-deployment-6876c87c8c-txrkj 1 /1 Running 0 2m9s pod/connaisseur-deployment-6876c87c8c-wvr7q 1 /1 Running 0 2m9s pod/connaisseur-deployment-6876c87c8c-rnc7k 1 /1 Running 0 2m9s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE service/connaisseur-svc ClusterIP 10 .152.183.166 <none> 443 /TCP 2m10s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/connaisseur-deployment 3 /3 3 3 2m9s NAME DESIRED CURRENT READY AGE replicaset.apps/connaisseur-deployment-6876c87c8c 3 3 3 2m9s","title":"Deploy Connaisseur"},{"location":"getting_started/#test-connaisseur","text":"Now that we created our key pairs, configured and deployed Connaisseur, the next step is to test our setup. So let's create and push a test image. Feel free to use our simple test Dockerfile under tests/Dockerfile (make sure to set your own IMAGE name): # Typically, IMAGE=<REGISTRY>/<REPOSITORY-NAME>/<IMAGE-NAME>:<TAG>, like IMAGE = docker.io/securesystemsengineering/demo:test docker build -f tests/Dockerfile -t ${ IMAGE } . docker push ${ IMAGE } In case you have DCT turned on per default via environment variable DOCKER_CONTENT_TRUST=1 , you should disable for now during the docker push by adding the --disable-content-trust=true . If we try to deploy this unsigned image: kubectl run test --image = ${ IMAGE } Connaisseur denies the request due to lack of trust data or signed digest, e.g.: Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request: Unable to get root trust data from default. # or Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request: No trust data for image \"docker.io/securesystemsengineering/demo:test\" . # or Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request: could not find signed digest for image \"docker.io/securesystemsengineering/demo:test\" in trust data. So let's sign the image and try again. Docker Content Trust In DCT signing works via docker push using the --disable-content-trust flag: docker push ${ IMAGE } --disable-content-trust = false You will be prompted to provide your password and might be asked to set a new repository key. The trust data will then be pushed to the Docker Hub Notary server. Cosign For Cosign, we use the private key file from the first step: cosign sign -key cosign.key ${ IMAGE } You will be asked to enter your password after wich the signature data will be pushed to your repository. After successful signing, we try again: kubectl run test --image = ${ IMAGE } Now, the request is admitted to the cluster and Kubernetes returns: pod/test created You did it you just verified your first signed images in your Kuberenetes cluster Read on to learn how to fully configure Connaisseur","title":"Test Connaisseur"},{"location":"getting_started/#cleanup","text":"To uninstall Connaisseur, use: helm uninstall connaisseur --namespace connaisseur Uninstallation can take a moment as Connaisseur needs to validate the deletion webhook.","title":"Cleanup"},{"location":"threat_model/","text":"Threat Model \u2693\ufe0e OUTDATED The STRIDE threat model has been used as a reference for threat modeling. Each of the STRIDE threats were matched to all entities relevant to Connaisseur, including Connaisseur itself. A description of how a threat on an entity manifests itself is given as well as a possible counter measure. images created by monkik from Noun Project (1) Developer/User \u2693\ufe0e Threat Description Counter Measure Spoofing A developer could be tricked into signing a malicious image, which subsequently will be accepted by Connaisseur. Security Awareness: Developers need to be aware of these attacks, so they can spot any attempts. Elevation of privilege An attacker could acquire the credentials of a developer or trick her into performing malicious actions, hence elevating their privileges to those of the victim. Depending on the victim's privileges, other attacks may be mounted. RBAC & Security Awareness: With proper Role-Based Access Control (RBAC), the effects of compromising an individual's account would help limit its impact and may mitigate the privilege escalation, of course depending on the victim's access level. Other than that, a security awareness training for developers can help minimize the chances of losing critical credentials. (2) Connaisseur service \u2693\ufe0e Threat Description Counter Measure Spoofing An attacker could stop the original Connaisseur service and start their own version, to take over the admission controller's responsibilities. That way, the functionality of Connaisseur could be completely disabled or altered at will. RBAC: By only permitting a carefully selected group of people to start and stop services in the Connaisseur namespace, such attacks can be prevented. Tampering Given an attacker has access to the Connaisseur container, she could tamper with its source code, leading to forged responses or full compromise. The attacker could also stop the the original Connaisseur process and handle incoming requests some other way, which would be similar to the spoofing threat, but from inside the Connaisseur container. RBAC + Monitoring: Access to the inside of the container can be restricted with RBAC, so an attacker never gets there in the first place. In case the attacker already is inside the container, there are specific monitoring tools (e.g. falco ), which are able to register changes inside containers and notify you, should Connaisseur be compromised. Tampering An attacker could modify Connaisseur's image policy to bypass signature verification and inject malicious images. Alternatively, the public root key could be replaced, allowing fake trust data to pass as legit. Lastly, the admission controller could be simply deactivated by deleting the webhook. RBAC + Monitoring: An RBAC system can prevent unauthorized changes to both the image policy and public root key. Additionally, the Connaisseur readiness probe checks the availability of the webhook and will be set to Not Ready should the webhook not be present. Monitoring should still be used to keep track of the admission controller's webhook availability status, as setting up a fake connaisseur-bootstrap-sentinel pod in the connaisseur namespace can bypass that readiness probe check. More on that in an upcoming architectural decision record. Denial of service When sending an extraordinary amount of requests to Connaisseur or triggering unexpected behavior, Connaisseur might become unresponsive or crash. As a result, image signatures can't be verified. Failure Policy: The webhook that is connected to Connaisseur denies all request automatically, should the Connaisseur service be unavailable. Thus, malicious images cannot enter the cluster. Additionally, multiple instances of Connaisseur can be run for better load balancing. Elevation of privilege Since Connaisseur interacts with the Kubernetes API, an attacker located inside the Connaisseur container can act on its behalf and use its permissions. RBAC: Per default, the Connaisseur service account only has read permissions to a few non-critical objects. (3) Notary server \u2693\ufe0e Threat Description Counter Measure Spoofing An attacker could mount a Monster-in-the-Middle attack between Notary and the Connaisseur service and act as a fake Notary, sending back false trust data. TLS: A TLS connection between Connaisseur and Notary ensures the Notary server's authenticity. Tampering With full control over the Notary server, the stored trust data can be manipulated to include digests of malicious images. Signatures: Changing the trust data would invalidate the signatures and thus fail the image verification. Additionally, the keys needed to create valid signatures are not stored in Notary, but offline on client side. Information disclosure As Notary is responsible for creating the snapshot and timestamp signatures, an attacker could steal those private keys, and create valid snapshot and timestamp signatures. Key rotation: The snapshot and timestamp keys can easily be rotated and changed frequently. The more cirtical root and target key are not stored on server side. Denial of service An extraordinary amount of requests to the Notary server could bring it down so that the Connaisseur service has no more trust data available to work with. Health Probe: Connaisseur's readiness and liveness probes check the Notary server's health every few seconds. Should Notary be unavailable, Connaisseur will switch into a not-ready state. As a consequence, the failure policy will automatically deny all requests. (4) Registry \u2693\ufe0e Threat Description Counter Measure Spoofing An attacker could mount a Monster-in-the-Middle attack between the registry and the Kubernetes cluster and act as a fake registry, sending back malicious images. TLS: A TLS connection between the Kubernetes cluster and the registry ensures that the registry is authentic. Tampering With full control over the registry, an attacker may introduce malicious images or change the layers of existing ones and thus inject malicious content. Image Digests: Introducing new images does not work as Connaisseur selects them by digest. An attacker would have to change the content of the corresponding digest layer, while the changes need to produce the same digest. Such a hash collision is considered practically impossible. If digests differ, the docker daemon underlying the cluster will deny the image. Denial of service An extraordinary amount of requests to the registry could bring it down, so that no images can be pulled from it. Out of scope: This threat is specific to registries, not Connaisseur.","title":"Threat Model"},{"location":"threat_model/#threat-model","text":"OUTDATED The STRIDE threat model has been used as a reference for threat modeling. Each of the STRIDE threats were matched to all entities relevant to Connaisseur, including Connaisseur itself. A description of how a threat on an entity manifests itself is given as well as a possible counter measure. images created by monkik from Noun Project","title":"Threat Model"},{"location":"threat_model/#1-developeruser","text":"Threat Description Counter Measure Spoofing A developer could be tricked into signing a malicious image, which subsequently will be accepted by Connaisseur. Security Awareness: Developers need to be aware of these attacks, so they can spot any attempts. Elevation of privilege An attacker could acquire the credentials of a developer or trick her into performing malicious actions, hence elevating their privileges to those of the victim. Depending on the victim's privileges, other attacks may be mounted. RBAC & Security Awareness: With proper Role-Based Access Control (RBAC), the effects of compromising an individual's account would help limit its impact and may mitigate the privilege escalation, of course depending on the victim's access level. Other than that, a security awareness training for developers can help minimize the chances of losing critical credentials.","title":"(1) Developer/User"},{"location":"threat_model/#2-connaisseur-service","text":"Threat Description Counter Measure Spoofing An attacker could stop the original Connaisseur service and start their own version, to take over the admission controller's responsibilities. That way, the functionality of Connaisseur could be completely disabled or altered at will. RBAC: By only permitting a carefully selected group of people to start and stop services in the Connaisseur namespace, such attacks can be prevented. Tampering Given an attacker has access to the Connaisseur container, she could tamper with its source code, leading to forged responses or full compromise. The attacker could also stop the the original Connaisseur process and handle incoming requests some other way, which would be similar to the spoofing threat, but from inside the Connaisseur container. RBAC + Monitoring: Access to the inside of the container can be restricted with RBAC, so an attacker never gets there in the first place. In case the attacker already is inside the container, there are specific monitoring tools (e.g. falco ), which are able to register changes inside containers and notify you, should Connaisseur be compromised. Tampering An attacker could modify Connaisseur's image policy to bypass signature verification and inject malicious images. Alternatively, the public root key could be replaced, allowing fake trust data to pass as legit. Lastly, the admission controller could be simply deactivated by deleting the webhook. RBAC + Monitoring: An RBAC system can prevent unauthorized changes to both the image policy and public root key. Additionally, the Connaisseur readiness probe checks the availability of the webhook and will be set to Not Ready should the webhook not be present. Monitoring should still be used to keep track of the admission controller's webhook availability status, as setting up a fake connaisseur-bootstrap-sentinel pod in the connaisseur namespace can bypass that readiness probe check. More on that in an upcoming architectural decision record. Denial of service When sending an extraordinary amount of requests to Connaisseur or triggering unexpected behavior, Connaisseur might become unresponsive or crash. As a result, image signatures can't be verified. Failure Policy: The webhook that is connected to Connaisseur denies all request automatically, should the Connaisseur service be unavailable. Thus, malicious images cannot enter the cluster. Additionally, multiple instances of Connaisseur can be run for better load balancing. Elevation of privilege Since Connaisseur interacts with the Kubernetes API, an attacker located inside the Connaisseur container can act on its behalf and use its permissions. RBAC: Per default, the Connaisseur service account only has read permissions to a few non-critical objects.","title":"(2) Connaisseur service"},{"location":"threat_model/#3-notary-server","text":"Threat Description Counter Measure Spoofing An attacker could mount a Monster-in-the-Middle attack between Notary and the Connaisseur service and act as a fake Notary, sending back false trust data. TLS: A TLS connection between Connaisseur and Notary ensures the Notary server's authenticity. Tampering With full control over the Notary server, the stored trust data can be manipulated to include digests of malicious images. Signatures: Changing the trust data would invalidate the signatures and thus fail the image verification. Additionally, the keys needed to create valid signatures are not stored in Notary, but offline on client side. Information disclosure As Notary is responsible for creating the snapshot and timestamp signatures, an attacker could steal those private keys, and create valid snapshot and timestamp signatures. Key rotation: The snapshot and timestamp keys can easily be rotated and changed frequently. The more cirtical root and target key are not stored on server side. Denial of service An extraordinary amount of requests to the Notary server could bring it down so that the Connaisseur service has no more trust data available to work with. Health Probe: Connaisseur's readiness and liveness probes check the Notary server's health every few seconds. Should Notary be unavailable, Connaisseur will switch into a not-ready state. As a consequence, the failure policy will automatically deny all requests.","title":"(3) Notary server"},{"location":"threat_model/#4-registry","text":"Threat Description Counter Measure Spoofing An attacker could mount a Monster-in-the-Middle attack between the registry and the Kubernetes cluster and act as a fake registry, sending back malicious images. TLS: A TLS connection between the Kubernetes cluster and the registry ensures that the registry is authentic. Tampering With full control over the registry, an attacker may introduce malicious images or change the layers of existing ones and thus inject malicious content. Image Digests: Introducing new images does not work as Connaisseur selects them by digest. An attacker would have to change the content of the corresponding digest layer, while the changes need to produce the same digest. Such a hash collision is considered practically impossible. If digests differ, the docker daemon underlying the cluster will deny the image. Denial of service An extraordinary amount of requests to the registry could bring it down, so that no images can be pulled from it. Out of scope: This threat is specific to registries, not Connaisseur.","title":"(4) Registry"},{"location":"adr/","text":"Architecture Decision Records \u2693\ufe0e We strive to make decisions taken during the devlopment of Connaisseur transparent, whenever they may seem weird or unintuitive towards someone new to the project. Hence, when encountering a problem that took either considerable time to find a solution for or that spawned a lot of discussion, be it internal or from the community, the decision with the factors leading up to the particular choice should be documented. Additionally, we should make clear what other options were under consideration and why they were discarded to help both with making the decision comprehensible to people not involved at the time but also to not repeat discussions at a later point in time. Since each Architecture Decision may be slightly different, the format is not completely set in stone. However, you should give at least title, status, some context, decisions taken and options discarded and some reasoning as to why one option was deemed better than the others.","title":"Architecture Decision Records"},{"location":"adr/#architecture-decision-records","text":"We strive to make decisions taken during the devlopment of Connaisseur transparent, whenever they may seem weird or unintuitive towards someone new to the project. Hence, when encountering a problem that took either considerable time to find a solution for or that spawned a lot of discussion, be it internal or from the community, the decision with the factors leading up to the particular choice should be documented. Additionally, we should make clear what other options were under consideration and why they were discarded to help both with making the decision comprehensible to people not involved at the time but also to not repeat discussions at a later point in time. Since each Architecture Decision may be slightly different, the format is not completely set in stone. However, you should give at least title, status, some context, decisions taken and options discarded and some reasoning as to why one option was deemed better than the others.","title":"Architecture Decision Records"},{"location":"adr/ADR-1_bootstrap-sentinel/","text":"ADR 1: Bootstrap Sentinel \u2693\ufe0e Status \u2693\ufe0e Amended in ADR-3 . Deprecated as of ADR-5 . Context \u2693\ufe0e Connaisseur's main components are a MutatingWebhookConfiguration and the Connaisseur Pods. The MutatingWebhookConfiguration intercepts requests to create or update Kubernetes resources and forwards them to the Connaisseur Pods tasked, on a high level, with verifying trust data. The order of deploying both components matters, since a blocking MutatingWebhookConfiguration without the Connaisseur Pods to answer its requests would also block the deployment of said Pods. In #3 it was noted that prior to version 1.1.5 of Connaisseur when looking at the Ready status of Connaisseur Pods, they could report Ready while being non-functional due to the MutatingWebhookConfiguration missing. However, as stated above the MutatingWebhookConfiguration can only be deployed after the Connaisseur Pods, which was solved by checking the Ready state of said Pods. If one were to add a dependency to this Ready state, such that it only shows Ready when the MutatingWebhookConfiguration exists, we run into a deadlock, where the MutatingWebhookConfiguration waits for the Pods and the Pods wait for the MutatingWebhookConfiguration. Considered options \u2693\ufe0e Option 1 \u2693\ufe0e At the start of the Helm deployment, one can create a Pod named connaisseur-bootstrap-sentinel that will run for 5 minutes (which is also the installation timeout by Helm). Connaisseur Pods will report Ready if they can 1) access notary AND 2) the MutatingWebhookConfiguration exists OR 3) the connaisseur-bootstrap-sentinel Pod is still running. If 1) AND 2) both hold true, the sentinel is killed even if the 5 minutes have not passed yet. Option 2 \u2693\ufe0e Let Connaisseur's Pod readiness stay non-indicative of Connaisseur functioning and advertise that someone running Connaisseur has to monitor the MutatingWebhookConfiguration in order to ensure proper working. Option 3 \u2693\ufe0e Deploy MutatingWebhookConfiguration through Helm when Connaisseur Pods are healthy instead of when ready. Require Pod started and working notary connection for health and require additionally the existence of the MutatingWebhookConfiguration for readiness. Decision outcome \u2693\ufe0e We chose option 1 over option 2, because it was important to us that a brief glance at Connaisseur's Namespace allows one to judge whether it is running properly. Option 3 was not chosen as the readiness status of Pods can be easily seen from the Service, whereas the health status would require querying every single Pod individually. We deemed that to be a very ugly, non-kubernetes-y solution and hence decided against it. Positive consequences \u2693\ufe0e If the Connaisseur Pods report Ready during the connaisseur-bootstrap-sentinel 's runtime, the MutatingWebhookConfiguration will be deployed by Helm. Otherwise, the Helm deployment will fail after its timeout period (default: 5min), since there won't be a running connaisseur-bootstrap-sentinel Pod anymore that resolves the installation deadlock. The Connaisseur Pods will never reach the Ready state and the MutatingWebhookConfiguration never gets deployed. This means, we get consistent deployment failures after the inital waiting period if something did not work out. Additionally, if the MutatingWebhookConfiguration gets removed for whatever reason during operation, Connaisseur Pods will be failing, indicating their failed dependency. Hence, monitoring the Connaisseur Pods is sufficient to ensure their working. Negative consequences \u2693\ufe0e On the other hand, if an adversary can deploy a Pod named connaisseur-bootstrap-sentinel to Connaisseur's Namespace, the Connaisseur Pods will always show Ready regardless of the MutatingWebhookConfiguration. However, if an adversary can deploy to Connaisseur's Namespace, chances are Connaisseur can be compromised anyways. More importantly, if not a single Connaisseur Pod is successfully deployed or if the notary healthcheck fails during the sentinel's lifetime, then the deployment will fail regardless of possible recovery at a later time. Another issue would be the connaisseur-bootstrap-sentinel Pod being left behind, however since it has a very limited use case we can also clean it up during the deployment, so apart from the minimal additional complexity of the deployment this is a non-issue.","title":"ADR 1: Bootstrap Sentinel"},{"location":"adr/ADR-1_bootstrap-sentinel/#adr-1-bootstrap-sentinel","text":"","title":"ADR 1: Bootstrap Sentinel"},{"location":"adr/ADR-1_bootstrap-sentinel/#status","text":"Amended in ADR-3 . Deprecated as of ADR-5 .","title":"Status"},{"location":"adr/ADR-1_bootstrap-sentinel/#context","text":"Connaisseur's main components are a MutatingWebhookConfiguration and the Connaisseur Pods. The MutatingWebhookConfiguration intercepts requests to create or update Kubernetes resources and forwards them to the Connaisseur Pods tasked, on a high level, with verifying trust data. The order of deploying both components matters, since a blocking MutatingWebhookConfiguration without the Connaisseur Pods to answer its requests would also block the deployment of said Pods. In #3 it was noted that prior to version 1.1.5 of Connaisseur when looking at the Ready status of Connaisseur Pods, they could report Ready while being non-functional due to the MutatingWebhookConfiguration missing. However, as stated above the MutatingWebhookConfiguration can only be deployed after the Connaisseur Pods, which was solved by checking the Ready state of said Pods. If one were to add a dependency to this Ready state, such that it only shows Ready when the MutatingWebhookConfiguration exists, we run into a deadlock, where the MutatingWebhookConfiguration waits for the Pods and the Pods wait for the MutatingWebhookConfiguration.","title":"Context"},{"location":"adr/ADR-1_bootstrap-sentinel/#considered-options","text":"","title":"Considered options"},{"location":"adr/ADR-1_bootstrap-sentinel/#option-1","text":"At the start of the Helm deployment, one can create a Pod named connaisseur-bootstrap-sentinel that will run for 5 minutes (which is also the installation timeout by Helm). Connaisseur Pods will report Ready if they can 1) access notary AND 2) the MutatingWebhookConfiguration exists OR 3) the connaisseur-bootstrap-sentinel Pod is still running. If 1) AND 2) both hold true, the sentinel is killed even if the 5 minutes have not passed yet.","title":"Option 1"},{"location":"adr/ADR-1_bootstrap-sentinel/#option-2","text":"Let Connaisseur's Pod readiness stay non-indicative of Connaisseur functioning and advertise that someone running Connaisseur has to monitor the MutatingWebhookConfiguration in order to ensure proper working.","title":"Option 2"},{"location":"adr/ADR-1_bootstrap-sentinel/#option-3","text":"Deploy MutatingWebhookConfiguration through Helm when Connaisseur Pods are healthy instead of when ready. Require Pod started and working notary connection for health and require additionally the existence of the MutatingWebhookConfiguration for readiness.","title":"Option 3"},{"location":"adr/ADR-1_bootstrap-sentinel/#decision-outcome","text":"We chose option 1 over option 2, because it was important to us that a brief glance at Connaisseur's Namespace allows one to judge whether it is running properly. Option 3 was not chosen as the readiness status of Pods can be easily seen from the Service, whereas the health status would require querying every single Pod individually. We deemed that to be a very ugly, non-kubernetes-y solution and hence decided against it.","title":"Decision outcome"},{"location":"adr/ADR-1_bootstrap-sentinel/#positive-consequences","text":"If the Connaisseur Pods report Ready during the connaisseur-bootstrap-sentinel 's runtime, the MutatingWebhookConfiguration will be deployed by Helm. Otherwise, the Helm deployment will fail after its timeout period (default: 5min), since there won't be a running connaisseur-bootstrap-sentinel Pod anymore that resolves the installation deadlock. The Connaisseur Pods will never reach the Ready state and the MutatingWebhookConfiguration never gets deployed. This means, we get consistent deployment failures after the inital waiting period if something did not work out. Additionally, if the MutatingWebhookConfiguration gets removed for whatever reason during operation, Connaisseur Pods will be failing, indicating their failed dependency. Hence, monitoring the Connaisseur Pods is sufficient to ensure their working.","title":"Positive consequences"},{"location":"adr/ADR-1_bootstrap-sentinel/#negative-consequences","text":"On the other hand, if an adversary can deploy a Pod named connaisseur-bootstrap-sentinel to Connaisseur's Namespace, the Connaisseur Pods will always show Ready regardless of the MutatingWebhookConfiguration. However, if an adversary can deploy to Connaisseur's Namespace, chances are Connaisseur can be compromised anyways. More importantly, if not a single Connaisseur Pod is successfully deployed or if the notary healthcheck fails during the sentinel's lifetime, then the deployment will fail regardless of possible recovery at a later time. Another issue would be the connaisseur-bootstrap-sentinel Pod being left behind, however since it has a very limited use case we can also clean it up during the deployment, so apart from the minimal additional complexity of the deployment this is a non-issue.","title":"Negative consequences"},{"location":"adr/ADR-2_release-management/","text":"ADR 2: Release Management \u2693\ufe0e Status \u2693\ufe0e Proposed Context \u2693\ufe0e During its initial development Connaisseur was more or less maintained by a single person and not released frequently. Hence, the easiest option was to just have the maintainer build and push at certain stages of development. With the influx of more team members, the number of contributions and hence the number of needed/reasonable releases went up. Also since publication, it is more important that the uploaded Connaisseur image corresponds to the most recent version referenced in the Helm chart. A single person having to build, sign and push the images whenever a new pull request is accepted is hence unpractical for both development and agility. Considered options \u2693\ufe0e Choice 1 \u2693\ufe0e What branches to maintain Option 1 \u2693\ufe0e Continue with PRs from personal feature branches to master . Option 2 \u2693\ufe0e Have a development branch against which to create pull requests (during usual development, hotfixes may be different). Sub-options: - a develop (or similar) branch that will exist continuously - a v.1.5.0_dev (or similar) branch for each respective version Choice 2 \u2693\ufe0e Where to sign the images Option 1 \u2693\ufe0e Have the pipeline build, sign and push the images. Option 2 \u2693\ufe0e Have a maintainer build, sign and push the images. Decision outcome \u2693\ufe0e For choice 1, we decided to go for two branches. On the one hand, master being the branch that contains the code of the latest release and will be tagged with release versions. On the other hand, there will be a develop branch that hosts the current state of development and will be merged to master whenever we want to create a new release. This way we get rid of the current pain of releasing with every pull request at the cost a some overhead during release. In the process of automating most of the release process, we will run an integration test with locally built images for pull requests to master . Regarding choice 2, whenever a pull request is merged, whoever merged the PR has to tag this commit on the master branch with the most recent version. Right after the merge, whoever merged the PR builds, signs and pushes the new Connaisseur release and creates a tag on the master branch referencing the new release version. After the image is pushed and the new commit tagged, the pipeline will run the integration test with the image pulled from Docker Hub to ensure that the released version is working. We decided for this option as it does not expose credentials to GitHub Actions, which we wanted to avoid especially in light of the recent GitHub Actions injection attacks and as it would also prevent us from opening up the repository to Pull Requests. To alleviate the work required for doing the steps outside the pipeline we use a shell script that will automate these steps given suitable environment, i.e. Docker context and DCT keys. Positive consequences \u2693\ufe0e We can develop without having to ship changes immediatly. Release process does not expose credentials to GitHub Actions. Code gets Git tags. Negative consequences \u2693\ufe0e Process from code to release for a single change is more cumbersome than right now. Release still requires human intervention.","title":"ADR 2: Release Management"},{"location":"adr/ADR-2_release-management/#adr-2-release-management","text":"","title":"ADR 2: Release Management"},{"location":"adr/ADR-2_release-management/#status","text":"Proposed","title":"Status"},{"location":"adr/ADR-2_release-management/#context","text":"During its initial development Connaisseur was more or less maintained by a single person and not released frequently. Hence, the easiest option was to just have the maintainer build and push at certain stages of development. With the influx of more team members, the number of contributions and hence the number of needed/reasonable releases went up. Also since publication, it is more important that the uploaded Connaisseur image corresponds to the most recent version referenced in the Helm chart. A single person having to build, sign and push the images whenever a new pull request is accepted is hence unpractical for both development and agility.","title":"Context"},{"location":"adr/ADR-2_release-management/#considered-options","text":"","title":"Considered options"},{"location":"adr/ADR-2_release-management/#choice-1","text":"What branches to maintain","title":"Choice 1"},{"location":"adr/ADR-2_release-management/#option-1","text":"Continue with PRs from personal feature branches to master .","title":"Option 1"},{"location":"adr/ADR-2_release-management/#option-2","text":"Have a development branch against which to create pull requests (during usual development, hotfixes may be different). Sub-options: - a develop (or similar) branch that will exist continuously - a v.1.5.0_dev (or similar) branch for each respective version","title":"Option 2"},{"location":"adr/ADR-2_release-management/#choice-2","text":"Where to sign the images","title":"Choice 2"},{"location":"adr/ADR-2_release-management/#option-1_1","text":"Have the pipeline build, sign and push the images.","title":"Option 1"},{"location":"adr/ADR-2_release-management/#option-2_1","text":"Have a maintainer build, sign and push the images.","title":"Option 2"},{"location":"adr/ADR-2_release-management/#decision-outcome","text":"For choice 1, we decided to go for two branches. On the one hand, master being the branch that contains the code of the latest release and will be tagged with release versions. On the other hand, there will be a develop branch that hosts the current state of development and will be merged to master whenever we want to create a new release. This way we get rid of the current pain of releasing with every pull request at the cost a some overhead during release. In the process of automating most of the release process, we will run an integration test with locally built images for pull requests to master . Regarding choice 2, whenever a pull request is merged, whoever merged the PR has to tag this commit on the master branch with the most recent version. Right after the merge, whoever merged the PR builds, signs and pushes the new Connaisseur release and creates a tag on the master branch referencing the new release version. After the image is pushed and the new commit tagged, the pipeline will run the integration test with the image pulled from Docker Hub to ensure that the released version is working. We decided for this option as it does not expose credentials to GitHub Actions, which we wanted to avoid especially in light of the recent GitHub Actions injection attacks and as it would also prevent us from opening up the repository to Pull Requests. To alleviate the work required for doing the steps outside the pipeline we use a shell script that will automate these steps given suitable environment, i.e. Docker context and DCT keys.","title":"Decision outcome"},{"location":"adr/ADR-2_release-management/#positive-consequences","text":"We can develop without having to ship changes immediatly. Release process does not expose credentials to GitHub Actions. Code gets Git tags.","title":"Positive consequences"},{"location":"adr/ADR-2_release-management/#negative-consequences","text":"Process from code to release for a single change is more cumbersome than right now. Release still requires human intervention.","title":"Negative consequences"},{"location":"adr/ADR-3_multi_notary_config/","text":"ADR 3: Multiple Notary Configuration \u2693\ufe0e Status \u2693\ufe0e Accepted Context \u2693\ufe0e Previously Connaisseur only supported the configuration of a single notary, where all signature data had to reside in. Unfortunately this is rather impractical, as one doesn't create all signatures for all images one uses in a cluster. There is a need to access signature data from multiple places, like in a setup where most images come from a private registry + notary and some from Docker Hub and their notary. There is also the problem that a single notary instance could use multiple root keys, used for creating the signatures, like in the case of Docker Hub. Connaisseur also only supports a single root key to be trust pinned, thus making it impractical. That's why the decision was made to support more than one notary and multiple keys per notary, which leads to the question how the new configuration should look like. This also has implications on the notary health check, which is important for Connaisseur's own readiness check. Considered options \u2693\ufe0e Choice 1 \u2693\ufe0e The overall notary configuration setup in helm/values.yaml . Option 1 (Per Notary) \u2693\ufe0e The notary field becomes a list and changes to notaries . Per to be used notary instance, there will be one entry in this list. The entry will have the following data fields ( bold are mandatory): name -- A unique identifier for the notary configuration, which will be used in the image policy. host -- The host address of the notary instance. pub_root_keys -- A list of public root keys, which are to be used for signature verification. name -- An identifier for a single public root key, which will be used in the image policy. key -- The actual public root key in PEM format. selfsigned_cert -- A self-signed certificate in PEM format, for making secure TLS connection to the notary. auth -- Authentication details, should the notary require some. user -- Username to authenticate with. password -- Password to authenticate with. secretName -- Kubernetes secret reference to use INSTEAD of user/password combination. is_acr -- Marks the notary as being part of an Azure Container Registry. The image policy will have two additional fields per rule entry (in \"quotes\" are already present fields): \" pattern \" -- Image pattern to match against, for rule to apply. \" verify \" -- Whether the images should be verified or not. \" delegations \" -- List of required delegation roles. notary -- Which notary to use for any matching image. This has to correspond to a name field of one configured notary. What happens if none is given, is defined by the result of choice 2. key -- Which key to use for doing the signature verification. This has to correspond to a name field of one of the public keys configured for the notary corresponding to the image policy's notary field. What happens if none is given, is defined by the result of choice 2. Option 2 (Per Notary + Key) \u2693\ufe0e The notary field becomes a list and changes to notaries . Per notary + public root key combination, there is one entry. Meaning, for example, there will be one entry for Docker Hub and the public key for all official images and there will be another entry for Docker Hub and the public key for some private images. The entries will look identical to the one's from option 1, with two exceptions. The pub_root_keys field of the notary configurations won't be a list and only has a single entry, without needing to specify a key name. The image policy will only address the notary configuration to be chosen with the notary field, without the need for a key field. Choice 2 \u2693\ufe0e Default values for notary (and key ) inside the image policy. Option 1 (First item) \u2693\ufe0e When no notary is specified in a image policy rule, the first entry in the notaries configuration list is taken. The same goes for the public root key list, should option 1 for choice 1 be chosen. Problem: Might get inconsistent, should list ordering in python get shuffled around Option 2 (Explicit default) \u2693\ufe0e One of the notary configuration will be given a default field, which marks it as the default value. Problem: No real problems here, just an extra field that the user has to care about. Option 3 (Mandatory Notary) \u2693\ufe0e The notary (and potentially key ) field is mandatory for the image policy. Problem: Creates configuration overhead if many image policies use the same notary/key combination. Option 4 (Default name) \u2693\ufe0e If no notary or key are given in the image policy, it is assumed that one of the elements in the notary list or key list has name: \"default\" , which will then be taken. Should the assumption be wrong, an error is raised. Choice 3 \u2693\ufe0e Previously, the readiness probe for connaisseur also considered the notary's health for its own status. With multiple notary instances configured, this behavior changes. Option 1 (Ignore Notary) \u2693\ufe0e The readiness probe of Connaisseur will no longer be dependent on any notary health checks. The are completely decoupled. Problem: No knowledge that Connaisseur will automatically fail because of an unreachable notary, before one tries to deploy an image. Option 2 (Health check on all) \u2693\ufe0e In order for connaisseur to be ready, all configured notaries must be healthy and reachable. Problem: A single unreachable notary will \"disable\" Connaisseur's access to all others. Option 3 (Log Notary status) \u2693\ufe0e A mix of option 1 and 2, whereas the readiness of Connaisseur is independent of the notaries health check, but they are still being made, so unhealthy notaries can be logged. Problem: At what interval should be logged? Decision outcome \u2693\ufe0e Choice 1 \u2693\ufe0e Option 1 was chosen, to keep configurational duplication at a minimum. Choice 2 \u2693\ufe0e Option 4 was chosen. If more than one notary configuration or key within a configuration are present, one of those can be called \"default\" (setting the name field). That way it should be obvious enough, which configuration or key will be used, if not further specified within the image policy, while keeping configuration effort low. Choice 3 \u2693\ufe0e Option 3 was chosen. Notary and Connaisseur will be completely decoupled, with Connaisseur logging all notaries it can't reach. This way Connaisseur can still be operational, even with all notaries being unreachable. Otherwise Connaisseur would have blocked even images that were allowlisted. This is a breaking change, but we agreed that it is better as it allows e.g. deployments for which the respective image policy specifies verify: false .","title":"ADR 3: Multiple Notary Configuration"},{"location":"adr/ADR-3_multi_notary_config/#adr-3-multiple-notary-configuration","text":"","title":"ADR 3: Multiple Notary Configuration"},{"location":"adr/ADR-3_multi_notary_config/#status","text":"Accepted","title":"Status"},{"location":"adr/ADR-3_multi_notary_config/#context","text":"Previously Connaisseur only supported the configuration of a single notary, where all signature data had to reside in. Unfortunately this is rather impractical, as one doesn't create all signatures for all images one uses in a cluster. There is a need to access signature data from multiple places, like in a setup where most images come from a private registry + notary and some from Docker Hub and their notary. There is also the problem that a single notary instance could use multiple root keys, used for creating the signatures, like in the case of Docker Hub. Connaisseur also only supports a single root key to be trust pinned, thus making it impractical. That's why the decision was made to support more than one notary and multiple keys per notary, which leads to the question how the new configuration should look like. This also has implications on the notary health check, which is important for Connaisseur's own readiness check.","title":"Context"},{"location":"adr/ADR-3_multi_notary_config/#considered-options","text":"","title":"Considered options"},{"location":"adr/ADR-3_multi_notary_config/#choice-1","text":"The overall notary configuration setup in helm/values.yaml .","title":"Choice 1"},{"location":"adr/ADR-3_multi_notary_config/#option-1-per-notary","text":"The notary field becomes a list and changes to notaries . Per to be used notary instance, there will be one entry in this list. The entry will have the following data fields ( bold are mandatory): name -- A unique identifier for the notary configuration, which will be used in the image policy. host -- The host address of the notary instance. pub_root_keys -- A list of public root keys, which are to be used for signature verification. name -- An identifier for a single public root key, which will be used in the image policy. key -- The actual public root key in PEM format. selfsigned_cert -- A self-signed certificate in PEM format, for making secure TLS connection to the notary. auth -- Authentication details, should the notary require some. user -- Username to authenticate with. password -- Password to authenticate with. secretName -- Kubernetes secret reference to use INSTEAD of user/password combination. is_acr -- Marks the notary as being part of an Azure Container Registry. The image policy will have two additional fields per rule entry (in \"quotes\" are already present fields): \" pattern \" -- Image pattern to match against, for rule to apply. \" verify \" -- Whether the images should be verified or not. \" delegations \" -- List of required delegation roles. notary -- Which notary to use for any matching image. This has to correspond to a name field of one configured notary. What happens if none is given, is defined by the result of choice 2. key -- Which key to use for doing the signature verification. This has to correspond to a name field of one of the public keys configured for the notary corresponding to the image policy's notary field. What happens if none is given, is defined by the result of choice 2.","title":"Option 1 (Per Notary)"},{"location":"adr/ADR-3_multi_notary_config/#option-2-per-notary-key","text":"The notary field becomes a list and changes to notaries . Per notary + public root key combination, there is one entry. Meaning, for example, there will be one entry for Docker Hub and the public key for all official images and there will be another entry for Docker Hub and the public key for some private images. The entries will look identical to the one's from option 1, with two exceptions. The pub_root_keys field of the notary configurations won't be a list and only has a single entry, without needing to specify a key name. The image policy will only address the notary configuration to be chosen with the notary field, without the need for a key field.","title":"Option 2 (Per Notary + Key)"},{"location":"adr/ADR-3_multi_notary_config/#choice-2","text":"Default values for notary (and key ) inside the image policy.","title":"Choice 2"},{"location":"adr/ADR-3_multi_notary_config/#option-1-first-item","text":"When no notary is specified in a image policy rule, the first entry in the notaries configuration list is taken. The same goes for the public root key list, should option 1 for choice 1 be chosen. Problem: Might get inconsistent, should list ordering in python get shuffled around","title":"Option 1 (First item)"},{"location":"adr/ADR-3_multi_notary_config/#option-2-explicit-default","text":"One of the notary configuration will be given a default field, which marks it as the default value. Problem: No real problems here, just an extra field that the user has to care about.","title":"Option 2 (Explicit default)"},{"location":"adr/ADR-3_multi_notary_config/#option-3-mandatory-notary","text":"The notary (and potentially key ) field is mandatory for the image policy. Problem: Creates configuration overhead if many image policies use the same notary/key combination.","title":"Option 3 (Mandatory Notary)"},{"location":"adr/ADR-3_multi_notary_config/#option-4-default-name","text":"If no notary or key are given in the image policy, it is assumed that one of the elements in the notary list or key list has name: \"default\" , which will then be taken. Should the assumption be wrong, an error is raised.","title":"Option 4 (Default name)"},{"location":"adr/ADR-3_multi_notary_config/#choice-3","text":"Previously, the readiness probe for connaisseur also considered the notary's health for its own status. With multiple notary instances configured, this behavior changes.","title":"Choice 3"},{"location":"adr/ADR-3_multi_notary_config/#option-1-ignore-notary","text":"The readiness probe of Connaisseur will no longer be dependent on any notary health checks. The are completely decoupled. Problem: No knowledge that Connaisseur will automatically fail because of an unreachable notary, before one tries to deploy an image.","title":"Option 1 (Ignore Notary)"},{"location":"adr/ADR-3_multi_notary_config/#option-2-health-check-on-all","text":"In order for connaisseur to be ready, all configured notaries must be healthy and reachable. Problem: A single unreachable notary will \"disable\" Connaisseur's access to all others.","title":"Option 2 (Health check on all)"},{"location":"adr/ADR-3_multi_notary_config/#option-3-log-notary-status","text":"A mix of option 1 and 2, whereas the readiness of Connaisseur is independent of the notaries health check, but they are still being made, so unhealthy notaries can be logged. Problem: At what interval should be logged?","title":"Option 3 (Log Notary status)"},{"location":"adr/ADR-3_multi_notary_config/#decision-outcome","text":"","title":"Decision outcome"},{"location":"adr/ADR-3_multi_notary_config/#choice-1_1","text":"Option 1 was chosen, to keep configurational duplication at a minimum.","title":"Choice 1"},{"location":"adr/ADR-3_multi_notary_config/#choice-2_1","text":"Option 4 was chosen. If more than one notary configuration or key within a configuration are present, one of those can be called \"default\" (setting the name field). That way it should be obvious enough, which configuration or key will be used, if not further specified within the image policy, while keeping configuration effort low.","title":"Choice 2"},{"location":"adr/ADR-3_multi_notary_config/#choice-3_1","text":"Option 3 was chosen. Notary and Connaisseur will be completely decoupled, with Connaisseur logging all notaries it can't reach. This way Connaisseur can still be operational, even with all notaries being unreachable. Otherwise Connaisseur would have blocked even images that were allowlisted. This is a breaking change, but we agreed that it is better as it allows e.g. deployments for which the respective image policy specifies verify: false .","title":"Choice 3"},{"location":"adr/ADR-4_modular/","text":"ADR 4: Modular Validation \u2693\ufe0e Status \u2693\ufe0e Accepted Context \u2693\ufe0e With the upcoming of notaryv2 and similar projects like Cosign the opportunity for Connaisseur arises to support multiple signing mechanisms, and combine all into a single validation tool. For that to work, the internal validation mechanism of connaisseur needs to be more modular, so we can easily swap in and out different methods. Considered options \u2693\ufe0e Configuration changes (Choice 1) \u2693\ufe0e Obviously some changes have to be made to the configuration of Connaisseur, but this splits into changes for the previous notary configurations and the image policy. \"Notary\" configuration (1.1) \u2693\ufe0e With notaryv1 all trust data always resided in a notary server for which Connaisseur needed the URL, authentication credentials, etc. This isn't true anymore for notaryv2 or Cosign. Here Connaisseur may need other data, meaning the configuration is dependent on the type of validation method used here. Also other mechanisms such as digest whitelisting which doesn't even include cryptographic material might be considered in the future. 1.1.1 Structure \u2693\ufe0e Option 1.1.1.1 \u2693\ufe0e The previous notaries section in the values.yaml changes to validators , in which different validation methods (validators) can be defined. The least required fields a validator needs are a name for later referencing and a type for knowing its correct kind. validators : - name : \"dockerhub-nv2\" type : \"notaryv2\" ... - name : \"harbor-nv1\" type : \"notaryv1\" host : \"notary.harbor.io\" root_keys : - name : \"default\" key : \"...\" - name : \"cosign\" type : \"cosign\" ... Depending on the type, additional fields might be required, e.g. the notaryv1 type requires a host and root_keys field. NB: JSON schema validation works for the above and can easily handle various configurations based on type in there. Decision \u2693\ufe0e We are going with this structure ( option 1.1.1.1 ) due to the lack of other alternatives. It provides all needed information and the flexibility to use multiple validation methods, as needed. 1.1.2 Sensitive values \u2693\ufe0e If we allow multiple validators that may contain different forms of sensitive values, i.e. notary credentials, symmetric keys, service principals, ..., they need to be properly handled within the Helm chart with respect to ConfigMaps and Secrets. Currently, the distinction is hard-coded. Option 1.1.2.1 \u2693\ufe0e Add an optional sensitive([-_]fields) field at the validator config top level. Any sensitive values go in there and will be handled by the Helm chart to go into a secret. Any other values are treated as public and go into the ConfigMap. Advantages: - Generic configuration - Could be used by potential plugin validators to have their data properly handled (potential future) - Hard to forget the configuration for newly implemented validators Disadvantage: If implemented in a config = merge(secret, configmap) way, might allow sensitive values in configmap and Connaisseur still working Option 1.1.2.2 \u2693\ufe0e Hard-code sensitive values based on validator type Advantages: Can do very strict validation on fields without extra work Disadvantages: - Helm chart change might be forgotten for new validator - Helm chart release required for new validator - Does not \"natively\" allow plugins Decision \u2693\ufe0e We are going with option 1.1.2.2 and hard code the sensitive fields, to prevent users from misconfigure and accidentally but sensitive parts into configmaps. Image policy (1.2) \u2693\ufe0e For the image policy similar changes to the notary configuration have to be made. Proposition \u2693\ufe0e The previous notary field in the image policy will be changed to validator , referencing a name field of one item in the validators list. Any additional fields, e.g. required delegation roles for a notaryv1 validator will be given in a with field. This will look similar to this: policy : - pattern : \"docker.harbor.io/*:*\" validator : \"harbor-nv1\" with : key : \"default\" delegations : - lou - max - pattern : \"docker.io/*:*\" validator : \"dockerhub-nv2\" Option 1.2.1.1 \u2693\ufe0e Besides the self configured validator, two additional validators will be available: allow and deny . The allow validator will allow any image and the deny validator will deny anything. Advantages: More powerful than verify flag, i.e. has explicit deny option. Disadvantages: More config changes for users Option 1.2.1.2 \u2693\ufe0e Stick with current verify flag. Advantages: Config known for current users Disadvantages: No explicit deny option Decision \u2693\ufe0e We are going with option 1.2.1.1 , as we don't have to use additional fields and offer more powerful configuration options. Option 1.2.2.1 \u2693\ufe0e When no validator given, default to deny validator. Advantages: Easy Disadvantages: Not explicit Option 1.2.2.2 \u2693\ufe0e Require validator in policy config. Advantages: Explicit configuration, no accidental denying images Disadvantages: ? Decision \u2693\ufe0e We are going with option 1.2.2.1 as it reduces configurational effort and is consistent with the key selection behavior. Option 1.2.3.1 \u2693\ufe0e The validators from option 1.2.1.1 ( allow and deny ) will be purely internal, and additional validator can not be named \"allow\" or \"deny\". Advantages: Less configurational effort Disadvantage: A bit obscure for users Option 1.2.3.2 \u2693\ufe0e The allow and deny validator will be added to the default configuration as type: static with an extra argument (name up for discussion) that specifies whether everything should be denied or allowed. E.g.: validators : - name : allow type : static approve : true - name : deny type : static approve : false - ... Advantages: No obscurity, if user don't need these they can delete them. Disadvantage: Bigger config file ...? Decision \u2693\ufe0e We are going with option 1.2.3.2 as we favor less obscurity over the \"bigger\" configurational \"effort\". Validator interface (Choice 2) \u2693\ufe0e See validator interface Should validation return JSON patch or digest? Option 2.1.1 \u2693\ufe0e Validator.validate creates a JSON patch for the k8s request. Hence, different validators might make changes in addition to transforming tag to digest. Advantages: More flexibility in the future Disadvantages: We open the door to changes that are not core to Connaisseur functionality Option 2.1.2 \u2693\ufe0e Validator.validate returns a digest and Connaisseur uses the digest in a \"standardized\" way to create a JSON patch for the k8s request. Advantage: No code duplication and we stay with core feature of translating input data to trusted digest Disadvantages: Allowing additional changes would require additional work if we wanted to allow them in the future Decision \u2693\ufe0e We are going with option 2.1.2 as all current and upcoming validation methods return a digest.","title":"ADR 4: Modular Validation"},{"location":"adr/ADR-4_modular/#adr-4-modular-validation","text":"","title":"ADR 4: Modular Validation"},{"location":"adr/ADR-4_modular/#status","text":"Accepted","title":"Status"},{"location":"adr/ADR-4_modular/#context","text":"With the upcoming of notaryv2 and similar projects like Cosign the opportunity for Connaisseur arises to support multiple signing mechanisms, and combine all into a single validation tool. For that to work, the internal validation mechanism of connaisseur needs to be more modular, so we can easily swap in and out different methods.","title":"Context"},{"location":"adr/ADR-4_modular/#considered-options","text":"","title":"Considered options"},{"location":"adr/ADR-4_modular/#configuration-changes-choice-1","text":"Obviously some changes have to be made to the configuration of Connaisseur, but this splits into changes for the previous notary configurations and the image policy.","title":"Configuration changes (Choice 1)"},{"location":"adr/ADR-4_modular/#notary-configuration-11","text":"With notaryv1 all trust data always resided in a notary server for which Connaisseur needed the URL, authentication credentials, etc. This isn't true anymore for notaryv2 or Cosign. Here Connaisseur may need other data, meaning the configuration is dependent on the type of validation method used here. Also other mechanisms such as digest whitelisting which doesn't even include cryptographic material might be considered in the future.","title":"\"Notary\" configuration (1.1)"},{"location":"adr/ADR-4_modular/#111-structure","text":"","title":"1.1.1 Structure"},{"location":"adr/ADR-4_modular/#option-1111","text":"The previous notaries section in the values.yaml changes to validators , in which different validation methods (validators) can be defined. The least required fields a validator needs are a name for later referencing and a type for knowing its correct kind. validators : - name : \"dockerhub-nv2\" type : \"notaryv2\" ... - name : \"harbor-nv1\" type : \"notaryv1\" host : \"notary.harbor.io\" root_keys : - name : \"default\" key : \"...\" - name : \"cosign\" type : \"cosign\" ... Depending on the type, additional fields might be required, e.g. the notaryv1 type requires a host and root_keys field. NB: JSON schema validation works for the above and can easily handle various configurations based on type in there.","title":"Option 1.1.1.1"},{"location":"adr/ADR-4_modular/#decision","text":"We are going with this structure ( option 1.1.1.1 ) due to the lack of other alternatives. It provides all needed information and the flexibility to use multiple validation methods, as needed.","title":"Decision"},{"location":"adr/ADR-4_modular/#112-sensitive-values","text":"If we allow multiple validators that may contain different forms of sensitive values, i.e. notary credentials, symmetric keys, service principals, ..., they need to be properly handled within the Helm chart with respect to ConfigMaps and Secrets. Currently, the distinction is hard-coded.","title":"1.1.2 Sensitive values"},{"location":"adr/ADR-4_modular/#option-1121","text":"Add an optional sensitive([-_]fields) field at the validator config top level. Any sensitive values go in there and will be handled by the Helm chart to go into a secret. Any other values are treated as public and go into the ConfigMap. Advantages: - Generic configuration - Could be used by potential plugin validators to have their data properly handled (potential future) - Hard to forget the configuration for newly implemented validators Disadvantage: If implemented in a config = merge(secret, configmap) way, might allow sensitive values in configmap and Connaisseur still working","title":"Option 1.1.2.1"},{"location":"adr/ADR-4_modular/#option-1122","text":"Hard-code sensitive values based on validator type Advantages: Can do very strict validation on fields without extra work Disadvantages: - Helm chart change might be forgotten for new validator - Helm chart release required for new validator - Does not \"natively\" allow plugins","title":"Option 1.1.2.2"},{"location":"adr/ADR-4_modular/#decision_1","text":"We are going with option 1.1.2.2 and hard code the sensitive fields, to prevent users from misconfigure and accidentally but sensitive parts into configmaps.","title":"Decision"},{"location":"adr/ADR-4_modular/#image-policy-12","text":"For the image policy similar changes to the notary configuration have to be made.","title":"Image policy (1.2)"},{"location":"adr/ADR-4_modular/#proposition","text":"The previous notary field in the image policy will be changed to validator , referencing a name field of one item in the validators list. Any additional fields, e.g. required delegation roles for a notaryv1 validator will be given in a with field. This will look similar to this: policy : - pattern : \"docker.harbor.io/*:*\" validator : \"harbor-nv1\" with : key : \"default\" delegations : - lou - max - pattern : \"docker.io/*:*\" validator : \"dockerhub-nv2\"","title":"Proposition"},{"location":"adr/ADR-4_modular/#option-1211","text":"Besides the self configured validator, two additional validators will be available: allow and deny . The allow validator will allow any image and the deny validator will deny anything. Advantages: More powerful than verify flag, i.e. has explicit deny option. Disadvantages: More config changes for users","title":"Option 1.2.1.1"},{"location":"adr/ADR-4_modular/#option-1212","text":"Stick with current verify flag. Advantages: Config known for current users Disadvantages: No explicit deny option","title":"Option 1.2.1.2"},{"location":"adr/ADR-4_modular/#decision_2","text":"We are going with option 1.2.1.1 , as we don't have to use additional fields and offer more powerful configuration options.","title":"Decision"},{"location":"adr/ADR-4_modular/#option-1221","text":"When no validator given, default to deny validator. Advantages: Easy Disadvantages: Not explicit","title":"Option 1.2.2.1"},{"location":"adr/ADR-4_modular/#option-1222","text":"Require validator in policy config. Advantages: Explicit configuration, no accidental denying images Disadvantages: ?","title":"Option 1.2.2.2"},{"location":"adr/ADR-4_modular/#decision_3","text":"We are going with option 1.2.2.1 as it reduces configurational effort and is consistent with the key selection behavior.","title":"Decision"},{"location":"adr/ADR-4_modular/#option-1231","text":"The validators from option 1.2.1.1 ( allow and deny ) will be purely internal, and additional validator can not be named \"allow\" or \"deny\". Advantages: Less configurational effort Disadvantage: A bit obscure for users","title":"Option 1.2.3.1"},{"location":"adr/ADR-4_modular/#option-1232","text":"The allow and deny validator will be added to the default configuration as type: static with an extra argument (name up for discussion) that specifies whether everything should be denied or allowed. E.g.: validators : - name : allow type : static approve : true - name : deny type : static approve : false - ... Advantages: No obscurity, if user don't need these they can delete them. Disadvantage: Bigger config file ...?","title":"Option 1.2.3.2"},{"location":"adr/ADR-4_modular/#decision_4","text":"We are going with option 1.2.3.2 as we favor less obscurity over the \"bigger\" configurational \"effort\".","title":"Decision"},{"location":"adr/ADR-4_modular/#validator-interface-choice-2","text":"See validator interface Should validation return JSON patch or digest?","title":"Validator interface (Choice 2)"},{"location":"adr/ADR-4_modular/#option-211","text":"Validator.validate creates a JSON patch for the k8s request. Hence, different validators might make changes in addition to transforming tag to digest. Advantages: More flexibility in the future Disadvantages: We open the door to changes that are not core to Connaisseur functionality","title":"Option 2.1.1"},{"location":"adr/ADR-4_modular/#option-212","text":"Validator.validate returns a digest and Connaisseur uses the digest in a \"standardized\" way to create a JSON patch for the k8s request. Advantage: No code duplication and we stay with core feature of translating input data to trusted digest Disadvantages: Allowing additional changes would require additional work if we wanted to allow them in the future","title":"Option 2.1.2"},{"location":"adr/ADR-4_modular/#decision_5","text":"We are going with option 2.1.2 as all current and upcoming validation methods return a digest.","title":"Decision"},{"location":"adr/ADR-5_no-more-bootstrap/","text":"ADR 5: No More Bootstrap Pods \u2693\ufe0e Status \u2693\ufe0e Accepted Context \u2693\ufe0e Installing Connaisseur isn't as simple as one might think. There is more to it then just applying some yaml files, all due to the nature of being an admission controller, which might block itself in various ways. This ADR depicts some issues during installation of Connaisseur and shows solutions, that try make the process simpler and easier to understand. Problem 1 - Installation order \u2693\ufe0e Connaisseur's installation order is fairly critical. The webhook responsible for intercepting all requests is dependent on the Connaisseur pods and can only work, if those pods are available and ready. If not and FailurePolicy is set to Fail , the webhook will block anything and everything, including the Connaisseur pods themselves. This means, the webhook must be installed after the Connaisseur pods are ready. This was previously solved using the post-install Helm hook, which installs the webhook configuration after all other resources have been applied and are considered ready. Just for installation purposes, this solution suffices. A downside of this is, every resource installed via a Helm hook isn't natively considered to be part of the chart, meaning a helm uninstall would completely ignore those resources and leave the webhook configuration in place. Then the situation of everything and anything being blocked arises again. Additionally, upgrading won't be possible, since you can't tell Helm to temporarily delete resources and then reapply them. That's why the helm-hook image and bootstrap-sentinel where introduced. They were used to temporarily delete the webhook and reapply it before and after installations, in order to beat the race conditions. Unfortunately, this solution always felt a bit clunky and added a lot of complexity for a seemingly simple problem. Solution 1.1 - Empty webhook as part of Helm release \u2693\ufe0e The bootstrap sentinel and helm-hook image won't be used anymore. Instead, an empty webhook configuration (a configuration without any rules) will be applied along all other resources during the normal Helm installation phase. This way the webhook can be normally deleted with the helm uninstall command. Additionally, during the post-install (and post-upgrade / post-rollback ) Helm hook, the webhook will be updated so it can actually intercept incoming request. So in a sense an unloaded webhook gets installed, which then gets \"armed\" during post-install . This also works during an upgrade, since the now \"armed\" webhook will be overwritten by the empty one when trying to apply the chart again! This will obviously be reverted back again after upgrading, with a post-upgrade Helm hook. Pros: Less clunky and more k8s native. Cons: Connaisseur will be deactivated for a short time during upgrading. Solution 1.2 - Bootstrap Sentinel and Helm hook \u2693\ufe0e Everything stays as is! The Helm hook image is still used to (un)install the webhook, while the bootstrap sentinel is there to mark the Connaisseur pods as ready for initial installation. Pros: Never change a running system. Cons: Clunky, at times confusing for anyone not familiar with the Connaisseur installation order problem, inactive webhook during upgrade. Solution 1.3 - (Un)installation of webhook during Helm hooks \u2693\ufe0e The webhook can be easily installed during the post-install step of the Helm installation, but then it isn't part of the Helm release and can't be uninstalled, as mentioned above. With a neat little trick this is still possible: in the post-delete step the webhook can be reapplied in an empty (\"unarmed\") form, while setting the hook-delete-policy to delete the resource in either way (no matter if the Helm hook step fails or not). So in a way the webhook gets reapplied and then immediately deleted. This still works with upgrading Connaisseur if a rolling update strategy is pursued, meaning the old pods will still be available for admitting the new ones, while with more and more new pods being ready, the old ones get deleted. Pros: Less clunky and more k8s native, no inactivity of the webhook during upgrade. Cons: Slower upgrade of Connaisseur compared to solution 1. Decision outcome (1) \u2693\ufe0e Solution 1.3 was chosen, as it is the more Kubernetes native way of doing things and Connaisseur will be always available, even during its own upgrade. Problem 2 \u2693\ufe0e All admission webhooks must use TLS for communication purposes or they won't be accepted by Kubernetes. That is why Connaisseur creates its own self signed certificate, which it uses for communication between the webhook and its pods. This certificate is created within the Helm chart, using the native genSelfSignedCert function, which makes Connaisseur pipeline friendly as there is no need for additional package installation such as OpenSSL. Unfortunately, this certificate gets created every time Helm is used, whether that being a helm install or helm upgrade . Especially during an upgrade, the webhook will get a new certificate, while the pods will get their new one written into a secret. The problem is that the pods will only capitalize on the new certificate inside the secret once they are restarted. If no restart happens, the pods and webhook will have different certificates and any validation will fail. Solution 2.1 - Lookup \u2693\ufe0e Instead of always generating a new certificate, the lookup function for Helm templates could be used to see whether there already is a secret defined that contains a certificate and then use this one. This way the same certificate is reused the whole time so no pod restarts are necessary. Should there be no secret with certificate to begin with, a new one can be generated within the Helm chart. Pros: No need for restarts and changing of TLS certificates. Cons: The lookup function takes some time to gather the current certs. Solution 2.2 - Restart \u2693\ufe0e On each upgrade of the Helm release, all pods will be restarted so they incorporate the new TLS secrets. Pros: - Cons: Restarting takes time and may break if too many Connaisseur pods are unavailable at the same time. Solution 2.3 - External TLS \u2693\ufe0e Go back to using an external TLS certificate which is not being generated within the Helm chart, but by pre-configuring it or using OpenSSL. Pros: Fastest solution. Cons: More configurational effort and/or not pipeline friendly (may need OpenSSL). Decision outcome (2) \u2693\ufe0e Solution 2.1 is being implemented, as it is important that Connaisseur works with as little configuration effort as possible from the get-go. Nonetheless an external configuration of TLS certificates is still considered for later development. --","title":"ADR 5: No More Bootstrap Pods"},{"location":"adr/ADR-5_no-more-bootstrap/#adr-5-no-more-bootstrap-pods","text":"","title":"ADR 5: No More Bootstrap Pods"},{"location":"adr/ADR-5_no-more-bootstrap/#status","text":"Accepted","title":"Status"},{"location":"adr/ADR-5_no-more-bootstrap/#context","text":"Installing Connaisseur isn't as simple as one might think. There is more to it then just applying some yaml files, all due to the nature of being an admission controller, which might block itself in various ways. This ADR depicts some issues during installation of Connaisseur and shows solutions, that try make the process simpler and easier to understand.","title":"Context"},{"location":"adr/ADR-5_no-more-bootstrap/#problem-1-installation-order","text":"Connaisseur's installation order is fairly critical. The webhook responsible for intercepting all requests is dependent on the Connaisseur pods and can only work, if those pods are available and ready. If not and FailurePolicy is set to Fail , the webhook will block anything and everything, including the Connaisseur pods themselves. This means, the webhook must be installed after the Connaisseur pods are ready. This was previously solved using the post-install Helm hook, which installs the webhook configuration after all other resources have been applied and are considered ready. Just for installation purposes, this solution suffices. A downside of this is, every resource installed via a Helm hook isn't natively considered to be part of the chart, meaning a helm uninstall would completely ignore those resources and leave the webhook configuration in place. Then the situation of everything and anything being blocked arises again. Additionally, upgrading won't be possible, since you can't tell Helm to temporarily delete resources and then reapply them. That's why the helm-hook image and bootstrap-sentinel where introduced. They were used to temporarily delete the webhook and reapply it before and after installations, in order to beat the race conditions. Unfortunately, this solution always felt a bit clunky and added a lot of complexity for a seemingly simple problem.","title":"Problem 1 - Installation order"},{"location":"adr/ADR-5_no-more-bootstrap/#solution-11-empty-webhook-as-part-of-helm-release","text":"The bootstrap sentinel and helm-hook image won't be used anymore. Instead, an empty webhook configuration (a configuration without any rules) will be applied along all other resources during the normal Helm installation phase. This way the webhook can be normally deleted with the helm uninstall command. Additionally, during the post-install (and post-upgrade / post-rollback ) Helm hook, the webhook will be updated so it can actually intercept incoming request. So in a sense an unloaded webhook gets installed, which then gets \"armed\" during post-install . This also works during an upgrade, since the now \"armed\" webhook will be overwritten by the empty one when trying to apply the chart again! This will obviously be reverted back again after upgrading, with a post-upgrade Helm hook. Pros: Less clunky and more k8s native. Cons: Connaisseur will be deactivated for a short time during upgrading.","title":"Solution 1.1 - Empty webhook as part of Helm release"},{"location":"adr/ADR-5_no-more-bootstrap/#solution-12-bootstrap-sentinel-and-helm-hook","text":"Everything stays as is! The Helm hook image is still used to (un)install the webhook, while the bootstrap sentinel is there to mark the Connaisseur pods as ready for initial installation. Pros: Never change a running system. Cons: Clunky, at times confusing for anyone not familiar with the Connaisseur installation order problem, inactive webhook during upgrade.","title":"Solution 1.2 - Bootstrap Sentinel and Helm hook"},{"location":"adr/ADR-5_no-more-bootstrap/#solution-13-uninstallation-of-webhook-during-helm-hooks","text":"The webhook can be easily installed during the post-install step of the Helm installation, but then it isn't part of the Helm release and can't be uninstalled, as mentioned above. With a neat little trick this is still possible: in the post-delete step the webhook can be reapplied in an empty (\"unarmed\") form, while setting the hook-delete-policy to delete the resource in either way (no matter if the Helm hook step fails or not). So in a way the webhook gets reapplied and then immediately deleted. This still works with upgrading Connaisseur if a rolling update strategy is pursued, meaning the old pods will still be available for admitting the new ones, while with more and more new pods being ready, the old ones get deleted. Pros: Less clunky and more k8s native, no inactivity of the webhook during upgrade. Cons: Slower upgrade of Connaisseur compared to solution 1.","title":"Solution 1.3 - (Un)installation of webhook during Helm hooks"},{"location":"adr/ADR-5_no-more-bootstrap/#decision-outcome-1","text":"Solution 1.3 was chosen, as it is the more Kubernetes native way of doing things and Connaisseur will be always available, even during its own upgrade.","title":"Decision outcome (1)"},{"location":"adr/ADR-5_no-more-bootstrap/#problem-2","text":"All admission webhooks must use TLS for communication purposes or they won't be accepted by Kubernetes. That is why Connaisseur creates its own self signed certificate, which it uses for communication between the webhook and its pods. This certificate is created within the Helm chart, using the native genSelfSignedCert function, which makes Connaisseur pipeline friendly as there is no need for additional package installation such as OpenSSL. Unfortunately, this certificate gets created every time Helm is used, whether that being a helm install or helm upgrade . Especially during an upgrade, the webhook will get a new certificate, while the pods will get their new one written into a secret. The problem is that the pods will only capitalize on the new certificate inside the secret once they are restarted. If no restart happens, the pods and webhook will have different certificates and any validation will fail.","title":"Problem 2"},{"location":"adr/ADR-5_no-more-bootstrap/#solution-21-lookup","text":"Instead of always generating a new certificate, the lookup function for Helm templates could be used to see whether there already is a secret defined that contains a certificate and then use this one. This way the same certificate is reused the whole time so no pod restarts are necessary. Should there be no secret with certificate to begin with, a new one can be generated within the Helm chart. Pros: No need for restarts and changing of TLS certificates. Cons: The lookup function takes some time to gather the current certs.","title":"Solution 2.1 - Lookup"},{"location":"adr/ADR-5_no-more-bootstrap/#solution-22-restart","text":"On each upgrade of the Helm release, all pods will be restarted so they incorporate the new TLS secrets. Pros: - Cons: Restarting takes time and may break if too many Connaisseur pods are unavailable at the same time.","title":"Solution 2.2 - Restart"},{"location":"adr/ADR-5_no-more-bootstrap/#solution-23-external-tls","text":"Go back to using an external TLS certificate which is not being generated within the Helm chart, but by pre-configuring it or using OpenSSL. Pros: Fastest solution. Cons: More configurational effort and/or not pipeline friendly (may need OpenSSL).","title":"Solution 2.3 - External TLS"},{"location":"adr/ADR-5_no-more-bootstrap/#decision-outcome-2","text":"Solution 2.1 is being implemented, as it is important that Connaisseur works with as little configuration effort as possible from the get-go. Nonetheless an external configuration of TLS certificates is still considered for later development. --","title":"Decision outcome (2)"},{"location":"adr/ADR-6_dynamic-config/","text":"ADR 6: Dynamic Configuration \u2693\ufe0e Status \u2693\ufe0e Accepted Context \u2693\ufe0e The configuration of validators are mounted into Connaisseur as a configmap, as it is common practice in the Kubernetes ecosystem. When this configmap is upgraded, say with a helm upgrade , the resource itself in Kubernetes is updated accordingly, but that doesn't mean it's automatically updated inside the pods which mounted it. That only occurs once the pods are restarted and until they are the pods still have an old version of the configuration lingering around. This is a fairly unintuitive behavior and the reason why Connaisseur doesn't mount the image policy into its pods. Instead, the pods have access to the kube API and get the image policy dynamically from there. The same could be done for the validator configuration, but there is also another solution. Problem 1 - Access to configuration \u2693\ufe0e How should Connaisseur get access to its configuration files? Solution 1.1 - Dynamic access \u2693\ufe0e This is the same solution as currently employed for the image policy configuration. The validators will get their own CustomResourceDefinition and Connaisseur gets access to this resource via RBAC so it can use the kube API to read the configuration. Pros: Pods don't need to be restarted and the configuration can be changed \"on the fly\", without using Helm. Cons: Not a very Kubernetes native approach and Connaisseur must always do some network requests to access its config. Solution 1.2 - Restart pods \u2693\ufe0e The other solution would be to use ConfigMaps for validators and image policy and then restart the pods, once there were changes in the configurations. This can be achieved by setting the hash of the config files as annotations into the deployment. If there are changes in the configuration, the hash will change and thus a new deployment will be rolled out as it has a new annotation. This corresponds to the suggestion made by Helm. Pros: Kubernetes native and no more CustomResourceDefinitions! Cons: No more \"on the fly\" changes. Decision Outcome (1) \u2693\ufe0e Solution 1.2 was chosen, going with the more Kubernetes native way. Problem 2 - How many configmaps are too many? \u2693\ufe0e When both the image policy and validator configurations are either CustomResourceDefinitions or ConfigMaps, is there still a need to separate them or can they be merged into one file? Solution 2.1 - 2 concerns, 2 resources \u2693\ufe0e There will be 2 resources, one for the image policy and one for the validators. Solution 2.2 - One to rule them all \u2693\ufe0e One Ring to rule them all, One Ring to find them, One Ring to bring them all and in the darkness bind them. Decision Outcome (2) \u2693\ufe0e Solution 2.2 was chosen as it is the more simpler of the two.","title":"ADR 6: Dynamic Configuration"},{"location":"adr/ADR-6_dynamic-config/#adr-6-dynamic-configuration","text":"","title":"ADR 6: Dynamic Configuration"},{"location":"adr/ADR-6_dynamic-config/#status","text":"Accepted","title":"Status"},{"location":"adr/ADR-6_dynamic-config/#context","text":"The configuration of validators are mounted into Connaisseur as a configmap, as it is common practice in the Kubernetes ecosystem. When this configmap is upgraded, say with a helm upgrade , the resource itself in Kubernetes is updated accordingly, but that doesn't mean it's automatically updated inside the pods which mounted it. That only occurs once the pods are restarted and until they are the pods still have an old version of the configuration lingering around. This is a fairly unintuitive behavior and the reason why Connaisseur doesn't mount the image policy into its pods. Instead, the pods have access to the kube API and get the image policy dynamically from there. The same could be done for the validator configuration, but there is also another solution.","title":"Context"},{"location":"adr/ADR-6_dynamic-config/#problem-1-access-to-configuration","text":"How should Connaisseur get access to its configuration files?","title":"Problem 1 - Access to configuration"},{"location":"adr/ADR-6_dynamic-config/#solution-11-dynamic-access","text":"This is the same solution as currently employed for the image policy configuration. The validators will get their own CustomResourceDefinition and Connaisseur gets access to this resource via RBAC so it can use the kube API to read the configuration. Pros: Pods don't need to be restarted and the configuration can be changed \"on the fly\", without using Helm. Cons: Not a very Kubernetes native approach and Connaisseur must always do some network requests to access its config.","title":"Solution 1.1 - Dynamic access"},{"location":"adr/ADR-6_dynamic-config/#solution-12-restart-pods","text":"The other solution would be to use ConfigMaps for validators and image policy and then restart the pods, once there were changes in the configurations. This can be achieved by setting the hash of the config files as annotations into the deployment. If there are changes in the configuration, the hash will change and thus a new deployment will be rolled out as it has a new annotation. This corresponds to the suggestion made by Helm. Pros: Kubernetes native and no more CustomResourceDefinitions! Cons: No more \"on the fly\" changes.","title":"Solution 1.2 - Restart pods"},{"location":"adr/ADR-6_dynamic-config/#decision-outcome-1","text":"Solution 1.2 was chosen, going with the more Kubernetes native way.","title":"Decision Outcome (1)"},{"location":"adr/ADR-6_dynamic-config/#problem-2-how-many-configmaps-are-too-many","text":"When both the image policy and validator configurations are either CustomResourceDefinitions or ConfigMaps, is there still a need to separate them or can they be merged into one file?","title":"Problem 2 - How many configmaps are too many?"},{"location":"adr/ADR-6_dynamic-config/#solution-21-2-concerns-2-resources","text":"There will be 2 resources, one for the image policy and one for the validators.","title":"Solution 2.1 - 2 concerns, 2 resources"},{"location":"adr/ADR-6_dynamic-config/#solution-22-one-to-rule-them-all","text":"One Ring to rule them all, One Ring to find them, One Ring to bring them all and in the darkness bind them.","title":"Solution 2.2 - One to rule them all"},{"location":"adr/ADR-6_dynamic-config/#decision-outcome-2","text":"Solution 2.2 was chosen as it is the more simpler of the two.","title":"Decision Outcome (2)"},{"location":"adr/ADR-7_wsgi-server/","text":"ADR 7: WSGI Server \u2693\ufe0e Status \u2693\ufe0e Accepted Context \u2693\ufe0e We were running the Flask WSGI application with the built-in Flask server, which is not meant for production. Problems are mainly due to potential debug shell on the server and single thread in default configuration. Both were mitigated in our setup, but we decided to test a proper WSGI server at some point. Especially the log entry * Serving Flask app 'connaisseur.flask_server' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. did cause anguish among users, see e.g. issue 11 . Considered options \u2693\ufe0e Choice 1: WSGI server \u2693\ufe0e There's plenty of WSGI server around and the question poses itself, which one to pick. Flask itself has a list of servers , there's comparisons around, for example here and here . The choice, which WSGI servers to test was somewhat arbitrary among better performing ones in the posts. Contenders were Bjoern, Cheroot, Flask, Gunicorn and uWSGI. Bjoern was immediately dropped, since it worked only with Python2. Later, during testing Bjoern did support Python3, but no TLS, so we stuck to dropping it. Gunicorn was tested for a bit, but since it delivered worse results than the others and it requires a writable worker-tmp-dir directory, it was also dropped from contention. The remaining three were tested over a rather long time of development, i.e. from before the first bit of validation parallelization to after the 2.0 release. All tests were run on local minikube/kind clusters with rather constrained resources in the expectation that this will still provide reasonable insight into the servers' behavior on regular production clusters. Test results \u2693\ufe0e Since the results span a longer timeframe and at least at first performed to find some way to distinguish the servers instead of having a clear plan, some tests feature a different configuration. If not specified different Cheroot was run with default configuration (minimum number of threads 10, no maximum limit), Flask in its default configuration and uWSGI with 2 processes and 1 thread (low because it already has a bigger footprint when idle to begin with). Connaisseur itself was configured with its default of 3 pods. Integration test \u2693\ufe0e Before parallelization \u2693\ufe0e Before paralellization was ever implemented, there were tests running the integration test on the cluster and seeing how often the test failed. The error rate across 50 executions was 8% (4/50) for Cheroot, 22% (11/50) for Flask and 12% (6/50) for uWSGI. These error rates could be as high because the non-parallelized fetching of notary trust data regularly took around 25 seconds with a maximum timeout of 30 seconds. With simple parallelization \u2693\ufe0e After parallelization (of fetching base trust data) was added, the tests were rerun. This time all 50 checks for all servers were run together with randomized order of servers for each of the 50 test runs. Error rates were 4% (2/50) for Cheroot and 6% (3/50) for uWSGI. Flask was not tested. Stress tests \u2693\ufe0e Complex requests \u2693\ufe0e There was a test setup with complex individual requests containing multiple different initContainers and containers or many instantiations of a particular image. The test was performed using kubectl apply -f loadtest.yaml on the below file. loadtest.yaml apiVersion: apps/v1 kind: Deployment metadata: name: redis-with-many-instances labels: app: redis loadtest: loadtest spec: selector: matchLabels: app: redis replicas: 1000 template: metadata: labels: app: redis spec: containers: - name: redis image: redis --- apiVersion: v1 kind: Pod metadata: name: pod-with-many-containers labels: loadtest: loadtest spec: containers: - name: container1 image: busybox command: ['sh', '-c', 'sleep 3600'] - name: container2 image: redis - name: container3 image: node - name: container4 image: nginx - name: container5 image: rabbitmq - name: container6 image: elasticsearch - name: container7 image: sonarqube --- apiVersion: v1 kind: Pod metadata: name: pod-with-many-containers-and-init-containers labels: loadtest: loadtest spec: containers: - name: container1 image: busybox command: ['sh', '-c', 'sleep 3600'] - name: container2 image: redis - name: container3 image: node - name: container4 image: nginx - name: container5 image: rabbitmq - name: container6 image: elasticsearch - name: container7 image: sonarqube initContainers: - name: init2 image: maven - name: init3 image: vault - name: init4 image: postgres --- apiVersion: v1 kind: Pod metadata: name: pod-with-some-containers-and-init-containers labels: loadtest: loadtest spec: containers: - name: container1 image: busybox command: ['sh', '-c', 'sleep 3600'] - name: container2 image: redis - name: container3 image: node - name: container4 image: nginx initContainers: - name: container5 image: rabbitmq - name: container6 image: elasticsearch - name: container7 image: sonarqube --- apiVersion: v1 kind: Pod metadata: name: pod-with-coinciding-containers-and-init-containers labels: loadtest: loadtest spec: containers: - name: container1 image: busybox command: ['sh', '-c', 'sleep 3600'] - name: container2 image: redis - name: container3 image: node initContainers: - name: init1 image: busybox command: ['sh', '-c', 'sleep 3600'] - name: init2 image: redis - name: init3 image: node None of the servers regularly managed to pass this particular loadtest. However, the pods powered by the Flask server regularly died and had to be restarted, whereas both Cheroot and uWSGI had nearly no restarts and never on all instances. uWSGI seldomly even managed to pass the test. Less complex requests with some load \u2693\ufe0e Since in the above the most complex request was the bottleneck, we tried an instance of the test with less complexity in the individual requests but more requests instead. However, that led to no real distinguishing behaviour across the servers. Load test \u2693\ufe0e To check the servers behaviour when hit with lots of (easy) requests at the same time, we also implemented an actual load test. We ran parallel --jobs 20 ./testn.sh {1} :::: <(seq 200) and parallel --jobs 50 ./testn.sh {1} :::: <(seq 200) with the below files. File contents testn.sh nr=$1 tmpf=$(mktemp) filec=$(nr=${nr} envsubst ${tmpf}) kubectl apply -f ${tmpf} loadtest3.yaml apiVersion: apps/v1 kind: Deployment metadata: name: redis-${nr} labels: app: redis loadtest: loadtest spec: selector: matchLabels: app: redis replicas: 1 template: metadata: labels: app: redis spec: containers: - name: redis image: redis Afterwards, we checked how many of the pods were actually created. Server Created pods (parallel 20 jobs) Created pods (parallel 50 jobs) Cheroot 173 78 Cheroot (numthreads=40) - 81 Flask 173 81 uWSGI 49 - uWSGI (1 process, 10 threads) 164 35 uWSGI (4 processes, 10 threads) 146 135 uWSGI (1 process, 40 threads) 164 112 Interestingly, Flask (narrowly) performs best for this test (for strong load, not for massive load) and for both Cheroot and uWSGI adding further parallelization doesn't necessarily help the stability even when intuitively it should. For 50 jobs in parallel the low creation rate is due to the pods dying at some point during the barrage. Resource consumption measured via kubectl top pods -n connaisseur during the loadtest: Shown is representative sample from across multiple invocations only at 20 jobs, since for 50 jobs most often the pods died and metrics API is slow to give accurate information after restart. Cheroot NAME CPU(cores) MEMORY(bytes) connaisseur-deployment-644458d686-2tfjp 331m 46Mi connaisseur-deployment-644458d686-kfzdq 209m 44Mi connaisseur-deployment-644458d686-t57lp 321m 53Mi Flask NAME CPU(cores) MEMORY(bytes) connaisseur-deployment-644458d686-t6c24 381m 42Mi connaisseur-deployment-644458d686-thgzd 328m 42Mi connaisseur-deployment-644458d686-wcprp 235m 38Mi uWSGI (1 process, 10 threads) NAME CPU(cores) MEMORY(bytes) connaisseur-deployment-d86fbfcd8-9c5m7 129m 63Mi connaisseur-deployment-d86fbfcd8-hv6sp 309m 67Mi connaisseur-deployment-d86fbfcd8-w46dz 298m 67Mi Option 1.1: Flask \u2693\ufe0e Staying with the Flask server is obviously an option. It doesn't resolve the problem, but it did us a good service and there's no known problems with its usage in practice. However, the authors discourage using it: When running publicly rather than in development, you should not use the built-in development server (flask run). The development server is provided by Werkzeug for convenience, but is not designed to be particularly efficient, stable, or secure. source and it performs worst by far for complex requests. Option 1.2: Cheroot \u2693\ufe0e Cheroot performs better than Flask for complex requests and better than uWSGI when under strong load. However, when under massive load, even increasing its minimum number of threads doesn't really add a lot to its stability. In addition, it seems to be less known and not among the servers that the Flask project lists. On the other hand, its memory footprint is better than uWSGI's and almost on par with Flask's, whereas its CPU footprint is on par with uWSGI and slightly better than the one of Flask. Option 1.2: uWSGI \u2693\ufe0e uWSGI (narrowly) has the best showing for complex requests, but performs worst for strong load. However, if trying to deal with a massive load, scaling its resources allows uWSGI to significantly outperform the other options for very massive load. Its memory footprint is higher than for Cheroot and Flask, but its CPU footprint is on par with Cheroot and slightly better than Flask's. Decision \u2693\ufe0e We chose option 1.2 and will for now go forward with Cheroot as the WSGI server. The decision was based on the server performing best in the relevant parts of the stress and load tests.","title":"ADR 7: WSGI Server"},{"location":"adr/ADR-7_wsgi-server/#adr-7-wsgi-server","text":"","title":"ADR 7: WSGI Server"},{"location":"adr/ADR-7_wsgi-server/#status","text":"Accepted","title":"Status"},{"location":"adr/ADR-7_wsgi-server/#context","text":"We were running the Flask WSGI application with the built-in Flask server, which is not meant for production. Problems are mainly due to potential debug shell on the server and single thread in default configuration. Both were mitigated in our setup, but we decided to test a proper WSGI server at some point. Especially the log entry * Serving Flask app 'connaisseur.flask_server' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. did cause anguish among users, see e.g. issue 11 .","title":"Context"},{"location":"adr/ADR-7_wsgi-server/#considered-options","text":"","title":"Considered options"},{"location":"adr/ADR-7_wsgi-server/#choice-1-wsgi-server","text":"There's plenty of WSGI server around and the question poses itself, which one to pick. Flask itself has a list of servers , there's comparisons around, for example here and here . The choice, which WSGI servers to test was somewhat arbitrary among better performing ones in the posts. Contenders were Bjoern, Cheroot, Flask, Gunicorn and uWSGI. Bjoern was immediately dropped, since it worked only with Python2. Later, during testing Bjoern did support Python3, but no TLS, so we stuck to dropping it. Gunicorn was tested for a bit, but since it delivered worse results than the others and it requires a writable worker-tmp-dir directory, it was also dropped from contention. The remaining three were tested over a rather long time of development, i.e. from before the first bit of validation parallelization to after the 2.0 release. All tests were run on local minikube/kind clusters with rather constrained resources in the expectation that this will still provide reasonable insight into the servers' behavior on regular production clusters.","title":"Choice 1: WSGI server"},{"location":"adr/ADR-7_wsgi-server/#test-results","text":"Since the results span a longer timeframe and at least at first performed to find some way to distinguish the servers instead of having a clear plan, some tests feature a different configuration. If not specified different Cheroot was run with default configuration (minimum number of threads 10, no maximum limit), Flask in its default configuration and uWSGI with 2 processes and 1 thread (low because it already has a bigger footprint when idle to begin with). Connaisseur itself was configured with its default of 3 pods.","title":"Test results"},{"location":"adr/ADR-7_wsgi-server/#integration-test","text":"","title":"Integration test"},{"location":"adr/ADR-7_wsgi-server/#before-parallelization","text":"Before paralellization was ever implemented, there were tests running the integration test on the cluster and seeing how often the test failed. The error rate across 50 executions was 8% (4/50) for Cheroot, 22% (11/50) for Flask and 12% (6/50) for uWSGI. These error rates could be as high because the non-parallelized fetching of notary trust data regularly took around 25 seconds with a maximum timeout of 30 seconds.","title":"Before parallelization"},{"location":"adr/ADR-7_wsgi-server/#with-simple-parallelization","text":"After parallelization (of fetching base trust data) was added, the tests were rerun. This time all 50 checks for all servers were run together with randomized order of servers for each of the 50 test runs. Error rates were 4% (2/50) for Cheroot and 6% (3/50) for uWSGI. Flask was not tested.","title":"With simple parallelization"},{"location":"adr/ADR-7_wsgi-server/#stress-tests","text":"","title":"Stress tests"},{"location":"adr/ADR-7_wsgi-server/#complex-requests","text":"There was a test setup with complex individual requests containing multiple different initContainers and containers or many instantiations of a particular image. The test was performed using kubectl apply -f loadtest.yaml on the below file. loadtest.yaml apiVersion: apps/v1 kind: Deployment metadata: name: redis-with-many-instances labels: app: redis loadtest: loadtest spec: selector: matchLabels: app: redis replicas: 1000 template: metadata: labels: app: redis spec: containers: - name: redis image: redis --- apiVersion: v1 kind: Pod metadata: name: pod-with-many-containers labels: loadtest: loadtest spec: containers: - name: container1 image: busybox command: ['sh', '-c', 'sleep 3600'] - name: container2 image: redis - name: container3 image: node - name: container4 image: nginx - name: container5 image: rabbitmq - name: container6 image: elasticsearch - name: container7 image: sonarqube --- apiVersion: v1 kind: Pod metadata: name: pod-with-many-containers-and-init-containers labels: loadtest: loadtest spec: containers: - name: container1 image: busybox command: ['sh', '-c', 'sleep 3600'] - name: container2 image: redis - name: container3 image: node - name: container4 image: nginx - name: container5 image: rabbitmq - name: container6 image: elasticsearch - name: container7 image: sonarqube initContainers: - name: init2 image: maven - name: init3 image: vault - name: init4 image: postgres --- apiVersion: v1 kind: Pod metadata: name: pod-with-some-containers-and-init-containers labels: loadtest: loadtest spec: containers: - name: container1 image: busybox command: ['sh', '-c', 'sleep 3600'] - name: container2 image: redis - name: container3 image: node - name: container4 image: nginx initContainers: - name: container5 image: rabbitmq - name: container6 image: elasticsearch - name: container7 image: sonarqube --- apiVersion: v1 kind: Pod metadata: name: pod-with-coinciding-containers-and-init-containers labels: loadtest: loadtest spec: containers: - name: container1 image: busybox command: ['sh', '-c', 'sleep 3600'] - name: container2 image: redis - name: container3 image: node initContainers: - name: init1 image: busybox command: ['sh', '-c', 'sleep 3600'] - name: init2 image: redis - name: init3 image: node None of the servers regularly managed to pass this particular loadtest. However, the pods powered by the Flask server regularly died and had to be restarted, whereas both Cheroot and uWSGI had nearly no restarts and never on all instances. uWSGI seldomly even managed to pass the test.","title":"Complex requests"},{"location":"adr/ADR-7_wsgi-server/#less-complex-requests-with-some-load","text":"Since in the above the most complex request was the bottleneck, we tried an instance of the test with less complexity in the individual requests but more requests instead. However, that led to no real distinguishing behaviour across the servers.","title":"Less complex requests with some load"},{"location":"adr/ADR-7_wsgi-server/#load-test","text":"To check the servers behaviour when hit with lots of (easy) requests at the same time, we also implemented an actual load test. We ran parallel --jobs 20 ./testn.sh {1} :::: <(seq 200) and parallel --jobs 50 ./testn.sh {1} :::: <(seq 200) with the below files. File contents testn.sh nr=$1 tmpf=$(mktemp) filec=$(nr=${nr} envsubst ${tmpf}) kubectl apply -f ${tmpf} loadtest3.yaml apiVersion: apps/v1 kind: Deployment metadata: name: redis-${nr} labels: app: redis loadtest: loadtest spec: selector: matchLabels: app: redis replicas: 1 template: metadata: labels: app: redis spec: containers: - name: redis image: redis Afterwards, we checked how many of the pods were actually created. Server Created pods (parallel 20 jobs) Created pods (parallel 50 jobs) Cheroot 173 78 Cheroot (numthreads=40) - 81 Flask 173 81 uWSGI 49 - uWSGI (1 process, 10 threads) 164 35 uWSGI (4 processes, 10 threads) 146 135 uWSGI (1 process, 40 threads) 164 112 Interestingly, Flask (narrowly) performs best for this test (for strong load, not for massive load) and for both Cheroot and uWSGI adding further parallelization doesn't necessarily help the stability even when intuitively it should. For 50 jobs in parallel the low creation rate is due to the pods dying at some point during the barrage. Resource consumption measured via kubectl top pods -n connaisseur during the loadtest: Shown is representative sample from across multiple invocations only at 20 jobs, since for 50 jobs most often the pods died and metrics API is slow to give accurate information after restart. Cheroot NAME CPU(cores) MEMORY(bytes) connaisseur-deployment-644458d686-2tfjp 331m 46Mi connaisseur-deployment-644458d686-kfzdq 209m 44Mi connaisseur-deployment-644458d686-t57lp 321m 53Mi Flask NAME CPU(cores) MEMORY(bytes) connaisseur-deployment-644458d686-t6c24 381m 42Mi connaisseur-deployment-644458d686-thgzd 328m 42Mi connaisseur-deployment-644458d686-wcprp 235m 38Mi uWSGI (1 process, 10 threads) NAME CPU(cores) MEMORY(bytes) connaisseur-deployment-d86fbfcd8-9c5m7 129m 63Mi connaisseur-deployment-d86fbfcd8-hv6sp 309m 67Mi connaisseur-deployment-d86fbfcd8-w46dz 298m 67Mi","title":"Load test"},{"location":"adr/ADR-7_wsgi-server/#option-11-flask","text":"Staying with the Flask server is obviously an option. It doesn't resolve the problem, but it did us a good service and there's no known problems with its usage in practice. However, the authors discourage using it: When running publicly rather than in development, you should not use the built-in development server (flask run). The development server is provided by Werkzeug for convenience, but is not designed to be particularly efficient, stable, or secure. source and it performs worst by far for complex requests.","title":"Option 1.1: Flask"},{"location":"adr/ADR-7_wsgi-server/#option-12-cheroot","text":"Cheroot performs better than Flask for complex requests and better than uWSGI when under strong load. However, when under massive load, even increasing its minimum number of threads doesn't really add a lot to its stability. In addition, it seems to be less known and not among the servers that the Flask project lists. On the other hand, its memory footprint is better than uWSGI's and almost on par with Flask's, whereas its CPU footprint is on par with uWSGI and slightly better than the one of Flask.","title":"Option 1.2: Cheroot"},{"location":"adr/ADR-7_wsgi-server/#option-12-uwsgi","text":"uWSGI (narrowly) has the best showing for complex requests, but performs worst for strong load. However, if trying to deal with a massive load, scaling its resources allows uWSGI to significantly outperform the other options for very massive load. Its memory footprint is higher than for Cheroot and Flask, but its CPU footprint is on par with Cheroot and slightly better than Flask's.","title":"Option 1.2: uWSGI"},{"location":"adr/ADR-7_wsgi-server/#decision","text":"We chose option 1.2 and will for now go forward with Cheroot as the WSGI server. The decision was based on the server performing best in the relevant parts of the stress and load tests.","title":"Decision"},{"location":"features/","text":"Overview \u2693\ufe0e Besides Connaisseur's central functionality, several additional features are available: Detection Mode : warn but do not block invalid images Namespaced Validation : restrict validation to dedicated namespaces Alerting : send alerts based on verification result Automatic Child Approval : configure approval of Kubernetes child resources In combination, these features help to improve usability and might better support the DevOps workflow. Switching Connaisseur to detection mode and alerting on non-compliant images can for example avoid service interruptions while still benefitting from improved supply-chain security. Feel free to propose new features that would make Connaisseur an even better experience","title":"Overview"},{"location":"features/#overview","text":"Besides Connaisseur's central functionality, several additional features are available: Detection Mode : warn but do not block invalid images Namespaced Validation : restrict validation to dedicated namespaces Alerting : send alerts based on verification result Automatic Child Approval : configure approval of Kubernetes child resources In combination, these features help to improve usability and might better support the DevOps workflow. Switching Connaisseur to detection mode and alerting on non-compliant images can for example avoid service interruptions while still benefitting from improved supply-chain security. Feel free to propose new features that would make Connaisseur an even better experience","title":"Overview"},{"location":"features/alerting/","text":"Alerting \u2693\ufe0e Connaisseur can send notifications on admission decisions to basically every REST endpoint that accepts JSON payloads. Supported interfaces \u2693\ufe0e Slack, Opsgenie and Keybase have pre-configured payloads that are ready to use. However, you can use the existing payload templates as an example how to model your own custom one. It is also possible to configure multiple interfaces for receiving alerts at the same time. Configuration options \u2693\ufe0e Currently, Connaisseur supports alerting on either admittance of images, denial of images or both. These event categories can be configured independently of each other under the relevant category (i.e. admit_request or reject_request ): Key Accepted values Default Required Description alerting.cluster_identifier string \"not specified\" Cluster identifier used in alert payload to distinguish between alerts from different clusters. alerting.<category>.template opsgenie , slack , keybase , ecs-1-12-0 or custom * - File in helm/alert_payload_templates/ to be used as alert payload template. alerting.<category>.receiver_url string - URL of alert-receiving endpoint. alerting.<category>.priority int 3 Priority of alert (to enable fitting Connaisseur alerts into alerts from other sources). alerting.<category>.custom_headers list[string] - Additional headers required by alert-receiving endpoint. alerting.<category>.payload_fields subyaml - Additional ( yaml ) key-value pairs to be appended to alert payload (as json ). alerting.<category>.fail_if_alert_sending_fails bool False Whether to make Connaisseur deny images if the corresponding alert cannot be successfully sent. *basename of the custom template file in helm/alerting_payload_templates without file extension Notes : The value for template needs to match an existing file of the pattern helm/alert_payload_templates/<template>.json ; so if you want to use a predefined one it needs to be one of slack , keybase , opsgenie or ecs-1-12-0 . For Opsgenie you need to configure an additional [\"Authorization: GenieKey <Your-Genie-Key>\"] header. For Elastic Common Schema 1.12.0 output, the receiver_url has to be an HTTP/S log ingester, such as Fluentd HTTP input or Logstash HTTP input . Also custom_headers needs to be set to [\"Content-Type: application/json\"] for Fluentd HTTP endpoints. fail_if_alert_sending_fails only comes into play for requests that Connaisseur would have admitted as other requests would have been denied in the first place. The setting can come handy if you want to run Connaisseur in detection mode but still make sure that you get notified about what is going on in your cluster. However, this setting will significantly impact cluster interaction for everyone (i.e. block any cluster change associated to an image) if the alert sending fails permanently, e.g. accidental deletion of your Slack Webhook App, GenieKey expired... Example \u2693\ufe0e For example, if you would like to receive notifications in Keybase whenever Connaisseur admits a request to your cluster, your alerting configuration would look similar to the following snippet: alerting: admit_request: templates: - template: keybase receiver_url: https://bots.keybase.io/webhookbot/<Your-Keybase-Hook-Token> Additional notes \u2693\ufe0e Creating a custom template \u2693\ufe0e Along the lines of the templates that already exist you can easily define custom templates for other endpoints. The following variables can be rendered during runtime into the payload: alert_message priority connaisseur_pod_id cluster timestamp request_id images Referring to any of these variables in the templates works by Jinja2 notation (e.g. {{ timestamp }} ). You can update your payload dynamically by adding payload fields in yaml representation in the payload_fields key which will be translated to JSON by Helm as is. If your REST endpoint requires particular headers, you can specify them as described above in custom_headers . Feel free to make a PR to share with the community if you add new neat templates for other third parties","title":"Alerting"},{"location":"features/alerting/#alerting","text":"Connaisseur can send notifications on admission decisions to basically every REST endpoint that accepts JSON payloads.","title":"Alerting"},{"location":"features/alerting/#supported-interfaces","text":"Slack, Opsgenie and Keybase have pre-configured payloads that are ready to use. However, you can use the existing payload templates as an example how to model your own custom one. It is also possible to configure multiple interfaces for receiving alerts at the same time.","title":"Supported interfaces"},{"location":"features/alerting/#configuration-options","text":"Currently, Connaisseur supports alerting on either admittance of images, denial of images or both. These event categories can be configured independently of each other under the relevant category (i.e. admit_request or reject_request ): Key Accepted values Default Required Description alerting.cluster_identifier string \"not specified\" Cluster identifier used in alert payload to distinguish between alerts from different clusters. alerting.<category>.template opsgenie , slack , keybase , ecs-1-12-0 or custom * - File in helm/alert_payload_templates/ to be used as alert payload template. alerting.<category>.receiver_url string - URL of alert-receiving endpoint. alerting.<category>.priority int 3 Priority of alert (to enable fitting Connaisseur alerts into alerts from other sources). alerting.<category>.custom_headers list[string] - Additional headers required by alert-receiving endpoint. alerting.<category>.payload_fields subyaml - Additional ( yaml ) key-value pairs to be appended to alert payload (as json ). alerting.<category>.fail_if_alert_sending_fails bool False Whether to make Connaisseur deny images if the corresponding alert cannot be successfully sent. *basename of the custom template file in helm/alerting_payload_templates without file extension Notes : The value for template needs to match an existing file of the pattern helm/alert_payload_templates/<template>.json ; so if you want to use a predefined one it needs to be one of slack , keybase , opsgenie or ecs-1-12-0 . For Opsgenie you need to configure an additional [\"Authorization: GenieKey <Your-Genie-Key>\"] header. For Elastic Common Schema 1.12.0 output, the receiver_url has to be an HTTP/S log ingester, such as Fluentd HTTP input or Logstash HTTP input . Also custom_headers needs to be set to [\"Content-Type: application/json\"] for Fluentd HTTP endpoints. fail_if_alert_sending_fails only comes into play for requests that Connaisseur would have admitted as other requests would have been denied in the first place. The setting can come handy if you want to run Connaisseur in detection mode but still make sure that you get notified about what is going on in your cluster. However, this setting will significantly impact cluster interaction for everyone (i.e. block any cluster change associated to an image) if the alert sending fails permanently, e.g. accidental deletion of your Slack Webhook App, GenieKey expired...","title":"Configuration options"},{"location":"features/alerting/#example","text":"For example, if you would like to receive notifications in Keybase whenever Connaisseur admits a request to your cluster, your alerting configuration would look similar to the following snippet: alerting: admit_request: templates: - template: keybase receiver_url: https://bots.keybase.io/webhookbot/<Your-Keybase-Hook-Token>","title":"Example"},{"location":"features/alerting/#additional-notes","text":"","title":"Additional notes"},{"location":"features/alerting/#creating-a-custom-template","text":"Along the lines of the templates that already exist you can easily define custom templates for other endpoints. The following variables can be rendered during runtime into the payload: alert_message priority connaisseur_pod_id cluster timestamp request_id images Referring to any of these variables in the templates works by Jinja2 notation (e.g. {{ timestamp }} ). You can update your payload dynamically by adding payload fields in yaml representation in the payload_fields key which will be translated to JSON by Helm as is. If your REST endpoint requires particular headers, you can specify them as described above in custom_headers . Feel free to make a PR to share with the community if you add new neat templates for other third parties","title":"Creating a custom template"},{"location":"features/automatic_child_approval/","text":"Automatic Child Approval \u2693\ufe0e This is currently an experimental feature that might unstable over time. As such, it is not part of our semantic versioning guarantees and we take the liberty to adjust or remove it with any version at any time without incrementing MAJOR or MINOR. Per default, Connaisseur uses automatic child approval by which the child of a Kubernetes resource is automatically admitted without re-verification of the signature in order to avoid duplicate validation and handle inconsistencies with the image policy. This behavior can be configured or even disabled. When automatic child approval is enabled, images that are deployed as part of already deployed objects (e.g. a Pod deployed as a child of a Deployment) are already validated and potentially mutated during admission of the parent. In consequence, the images of child resources are directly admitted without re-verification of the signature. This is done as the parent (and thus the child) has already been validated and might have been mutated, which would lead to duplicate validation and could cause image policy pattern mismatch. For example, given a Deployment which contains Pods with image:tag that gets mutated to contain Pods with image@sha256:digest . Then a) the Pod would not need another validation as the image was validated during the admittance of the Deployment and b) if there exists a specific rule with pattern image:tag and another less specific rule with image* , then after mutating the Deployment, the Pod would be falsely validated against image* instead of image:tag . To ensure the child resource is legit in this case, the parent resource is requested via the Kubernetes API and only those images it lists are accepted. When automatic child approval is disabled, Connaisseur only validates and potentially mutates Pod resources. There is trade-offs between the two behaviors: With automatic child approval, Connaisseur only verifies that the image reference in a child resource is the same as in the parent. This means that resources deployed prior to Connaisseur will never be validated until they are re-deployed even if a corresponding Pod is restarted. Consequently, a restarting Pod with an expired signature would still be admitted. However, this avoids unexpected failures when restarting Pods, avoids inconsistencies with the image policy and reduces the number of validations and thus the load. Furthermore, disabling automatic child approval also means that deployments with invalid images will be successful even though the Pods are denied. The extension of the feature (disabling, caching) is currently under development to improve security without compromising on usability. Configuration options \u2693\ufe0e automaticChildApproval in helm/values.yaml supports the following keys: Key Default Required Description enabled true true or false ; when false , Connaisseur will disable automatic child approval ttl ? Not yet implemented. See below Example \u2693\ufe0e In helm/values.yaml : automaticChildApproval: enabled: true Additional notes \u2693\ufe0e Caching TTL \u2693\ufe0e It is planned to implement a caching by which Connaisseur might perform automatic child approval only for a limited time after creation of the parent resource.","title":"Automatic Child Approval"},{"location":"features/automatic_child_approval/#automatic-child-approval","text":"This is currently an experimental feature that might unstable over time. As such, it is not part of our semantic versioning guarantees and we take the liberty to adjust or remove it with any version at any time without incrementing MAJOR or MINOR. Per default, Connaisseur uses automatic child approval by which the child of a Kubernetes resource is automatically admitted without re-verification of the signature in order to avoid duplicate validation and handle inconsistencies with the image policy. This behavior can be configured or even disabled. When automatic child approval is enabled, images that are deployed as part of already deployed objects (e.g. a Pod deployed as a child of a Deployment) are already validated and potentially mutated during admission of the parent. In consequence, the images of child resources are directly admitted without re-verification of the signature. This is done as the parent (and thus the child) has already been validated and might have been mutated, which would lead to duplicate validation and could cause image policy pattern mismatch. For example, given a Deployment which contains Pods with image:tag that gets mutated to contain Pods with image@sha256:digest . Then a) the Pod would not need another validation as the image was validated during the admittance of the Deployment and b) if there exists a specific rule with pattern image:tag and another less specific rule with image* , then after mutating the Deployment, the Pod would be falsely validated against image* instead of image:tag . To ensure the child resource is legit in this case, the parent resource is requested via the Kubernetes API and only those images it lists are accepted. When automatic child approval is disabled, Connaisseur only validates and potentially mutates Pod resources. There is trade-offs between the two behaviors: With automatic child approval, Connaisseur only verifies that the image reference in a child resource is the same as in the parent. This means that resources deployed prior to Connaisseur will never be validated until they are re-deployed even if a corresponding Pod is restarted. Consequently, a restarting Pod with an expired signature would still be admitted. However, this avoids unexpected failures when restarting Pods, avoids inconsistencies with the image policy and reduces the number of validations and thus the load. Furthermore, disabling automatic child approval also means that deployments with invalid images will be successful even though the Pods are denied. The extension of the feature (disabling, caching) is currently under development to improve security without compromising on usability.","title":"Automatic Child Approval"},{"location":"features/automatic_child_approval/#configuration-options","text":"automaticChildApproval in helm/values.yaml supports the following keys: Key Default Required Description enabled true true or false ; when false , Connaisseur will disable automatic child approval ttl ? Not yet implemented. See below","title":"Configuration options"},{"location":"features/automatic_child_approval/#example","text":"In helm/values.yaml : automaticChildApproval: enabled: true","title":"Example"},{"location":"features/automatic_child_approval/#additional-notes","text":"","title":"Additional notes"},{"location":"features/automatic_child_approval/#caching-ttl","text":"It is planned to implement a caching by which Connaisseur might perform automatic child approval only for a limited time after creation of the parent resource.","title":"Caching TTL"},{"location":"features/detection_mode/","text":"Detection Mode \u2693\ufe0e A detection mode is available in order to avoid interruptions of a running cluster, to support initial rollout or for testing purposes. In detection mode, Connaisseur admits all images to the cluster, but issues a warning 1 and logs an error message for images that do not comply with the policy or in case of other unexpected failures: kubectl run unsigned --image = docker.io/securesystemsengineering/testimage:unsigned > Warning: Unable to find signed digest for image docker.io/securesystemsengineering/testimage:unsigned. ( not denied due to DETECTION_MODE ) > pod/unsigned created To activate the detection mode, set the detectionMode flag to true in helm/values.yaml . Configuration options \u2693\ufe0e detectionMode in helm/values.yaml supports the following keys: Key Default Required Description detectionMode false true or false ; when detection mode is enabled, Connaisseur will warn but not deny requests with untrusted images. Example \u2693\ufe0e In helm/values.yaml : detectionMode: true Additional notes \u2693\ufe0e Failure policy vs. detection mode \u2693\ufe0e The detection mode is not to be confused with the failure policy ( deployment.failurePolicy in helm/values.yaml ) for the mutating admission controller: In detection mode, Conaisseur service admits all requests to the cluster independent of the validation result while the failure policy only takes effect when the service itself becomes unavailable. As such, both options are disjoint. While in default configuration, requests will be denied if either no valid image signature exists or the Connaisseur service is unavailable, setting failurePolicy to Ignore and detectionMode to true ensures that Connaisseur never blocks a request. The feature to send warnings to API clients as shown above was only introduced in Kubernetes v1.19 . However, warnings are only surfaced by kubectl in stderr to improve usability. Except for testing purposes, the respective error messages should either be handled via the cluster's log monitoring solution or by making use of Connaisseur's alerting feature . \u21a9","title":"Detection Mode"},{"location":"features/detection_mode/#detection-mode","text":"A detection mode is available in order to avoid interruptions of a running cluster, to support initial rollout or for testing purposes. In detection mode, Connaisseur admits all images to the cluster, but issues a warning 1 and logs an error message for images that do not comply with the policy or in case of other unexpected failures: kubectl run unsigned --image = docker.io/securesystemsengineering/testimage:unsigned > Warning: Unable to find signed digest for image docker.io/securesystemsengineering/testimage:unsigned. ( not denied due to DETECTION_MODE ) > pod/unsigned created To activate the detection mode, set the detectionMode flag to true in helm/values.yaml .","title":"Detection Mode"},{"location":"features/detection_mode/#configuration-options","text":"detectionMode in helm/values.yaml supports the following keys: Key Default Required Description detectionMode false true or false ; when detection mode is enabled, Connaisseur will warn but not deny requests with untrusted images.","title":"Configuration options"},{"location":"features/detection_mode/#example","text":"In helm/values.yaml : detectionMode: true","title":"Example"},{"location":"features/detection_mode/#additional-notes","text":"","title":"Additional notes"},{"location":"features/detection_mode/#failure-policy-vs-detection-mode","text":"The detection mode is not to be confused with the failure policy ( deployment.failurePolicy in helm/values.yaml ) for the mutating admission controller: In detection mode, Conaisseur service admits all requests to the cluster independent of the validation result while the failure policy only takes effect when the service itself becomes unavailable. As such, both options are disjoint. While in default configuration, requests will be denied if either no valid image signature exists or the Connaisseur service is unavailable, setting failurePolicy to Ignore and detectionMode to true ensures that Connaisseur never blocks a request. The feature to send warnings to API clients as shown above was only introduced in Kubernetes v1.19 . However, warnings are only surfaced by kubectl in stderr to improve usability. Except for testing purposes, the respective error messages should either be handled via the cluster's log monitoring solution or by making use of Connaisseur's alerting feature . \u21a9","title":"Failure policy vs. detection mode"},{"location":"features/metrics/","text":"Metrics \u2693\ufe0e Connaisseur exposes metrics about usage of the /mutate endpoint and general information about the python process using Prometheus Flask Exporter through the /metrics endpoint. This for example allows visualizing the number of allowed or denied resource requests. Example \u2693\ufe0e # HELP python_gc_objects_collected_total Objects collected during gc # TYPE python_gc_objects_collected_total counter python_gc_objects_collected_total{generation=\"0\"} 4422.0 python_gc_objects_collected_total{generation=\"1\"} 1866.0 python_gc_objects_collected_total{generation=\"2\"} 0.0 # HELP python_gc_objects_uncollectable_total Uncollectable object found during GC # TYPE python_gc_objects_uncollectable_total counter python_gc_objects_uncollectable_total{generation=\"0\"} 0.0 python_gc_objects_uncollectable_total{generation=\"1\"} 0.0 python_gc_objects_uncollectable_total{generation=\"2\"} 0.0 # HELP python_gc_collections_total Number of times this generation was collected # TYPE python_gc_collections_total counter python_gc_collections_total{generation=\"0\"} 163.0 python_gc_collections_total{generation=\"1\"} 14.0 python_gc_collections_total{generation=\"2\"} 1.0 # HELP python_info Python platform information # TYPE python_info gauge python_info{implementation=\"CPython\",major=\"3\",minor=\"10\",patchlevel=\"2\",version=\"3.10.2\"} 1.0 # HELP process_virtual_memory_bytes Virtual memory size in bytes. # TYPE process_virtual_memory_bytes gauge process_virtual_memory_bytes 6.1161472e+07 # HELP process_resident_memory_bytes Resident memory size in bytes. # TYPE process_resident_memory_bytes gauge process_resident_memory_bytes 4.595712e+07 # HELP process_start_time_seconds Start time of the process since unix epoch in seconds. # TYPE process_start_time_seconds gauge process_start_time_seconds 1.6436681112e+09 # HELP process_cpu_seconds_total Total user and system CPU time spent in seconds. # TYPE process_cpu_seconds_total counter process_cpu_seconds_total 3.3 # HELP process_open_fds Number of open file descriptors. # TYPE process_open_fds gauge process_open_fds 12.0 # HELP process_max_fds Maximum number of open file descriptors. # TYPE process_max_fds gauge process_max_fds 1.048576e+06 # HELP exporter_info Information about the Prometheus Flask exporter # TYPE exporter_info gauge exporter_info{version=\"0.18.7\"} 1.0 # HELP http_request_duration_seconds Flask HTTP request duration in seconds # TYPE http_request_duration_seconds histogram http_request_duration_seconds_bucket{le=\"0.1\",method=\"POST\",path=\"/mutate\",status=\"200\"} 5.0 http_request_duration_seconds_bucket{le=\"0.25\",method=\"POST\",path=\"/mutate\",status=\"200\"} 5.0 http_request_duration_seconds_bucket{le=\"0.5\",method=\"POST\",path=\"/mutate\",status=\"200\"} 5.0 http_request_duration_seconds_bucket{le=\"0.75\",method=\"POST\",path=\"/mutate\",status=\"200\"} 8.0 http_request_duration_seconds_bucket{le=\"1.0\",method=\"POST\",path=\"/mutate\",status=\"200\"} 8.0 http_request_duration_seconds_bucket{le=\"2.5\",method=\"POST\",path=\"/mutate\",status=\"200\"} 9.0 http_request_duration_seconds_bucket{le=\"+Inf\",method=\"POST\",path=\"/mutate\",status=\"200\"} 9.0 http_request_duration_seconds_count{method=\"POST\",path=\"/mutate\",status=\"200\"} 9.0 http_request_duration_seconds_sum{method=\"POST\",path=\"/mutate\",status=\"200\"} 3.6445974350208417 # HELP http_request_duration_seconds_created Flask HTTP request duration in seconds # TYPE http_request_duration_seconds_created gauge http_request_duration_seconds_created{method=\"POST\",path=\"/mutate\",status=\"200\"} 1.643668194758098e+09 # HELP http_request_total Total number of HTTP requests # TYPE http_request_total counter http_request_total{method=\"POST\",status=\"200\"} 9.0 # HELP http_request_created Total number of HTTP requests # TYPE http_request_created gauge http_request_created{method=\"POST\",status=\"200\"} 1.6436681947581613e+09 # HELP http_request_exceptions_total Total number of HTTP requests which resulted in an exception # TYPE http_request_exceptions_total counter # HELP mutate_requests_total Total number of mutate requests # TYPE mutate_requests_total counter mutate_requests_total{allowed=\"False\",status_code=\"403\"} 4.0 mutate_requests_total{allowed=\"True\",status_code=\"202\"} 5.0 # HELP mutate_requests_created Total number of mutate requests # TYPE mutate_requests_created gauge mutate_requests_created{allowed=\"False\",status_code=\"403\"} 1.643760946491879e+09 mutate_requests_created{allowed=\"True\",status_code=\"202\"} 1.6437609592007663e+09","title":"Metrics"},{"location":"features/metrics/#metrics","text":"Connaisseur exposes metrics about usage of the /mutate endpoint and general information about the python process using Prometheus Flask Exporter through the /metrics endpoint. This for example allows visualizing the number of allowed or denied resource requests.","title":"Metrics"},{"location":"features/metrics/#example","text":"# HELP python_gc_objects_collected_total Objects collected during gc # TYPE python_gc_objects_collected_total counter python_gc_objects_collected_total{generation=\"0\"} 4422.0 python_gc_objects_collected_total{generation=\"1\"} 1866.0 python_gc_objects_collected_total{generation=\"2\"} 0.0 # HELP python_gc_objects_uncollectable_total Uncollectable object found during GC # TYPE python_gc_objects_uncollectable_total counter python_gc_objects_uncollectable_total{generation=\"0\"} 0.0 python_gc_objects_uncollectable_total{generation=\"1\"} 0.0 python_gc_objects_uncollectable_total{generation=\"2\"} 0.0 # HELP python_gc_collections_total Number of times this generation was collected # TYPE python_gc_collections_total counter python_gc_collections_total{generation=\"0\"} 163.0 python_gc_collections_total{generation=\"1\"} 14.0 python_gc_collections_total{generation=\"2\"} 1.0 # HELP python_info Python platform information # TYPE python_info gauge python_info{implementation=\"CPython\",major=\"3\",minor=\"10\",patchlevel=\"2\",version=\"3.10.2\"} 1.0 # HELP process_virtual_memory_bytes Virtual memory size in bytes. # TYPE process_virtual_memory_bytes gauge process_virtual_memory_bytes 6.1161472e+07 # HELP process_resident_memory_bytes Resident memory size in bytes. # TYPE process_resident_memory_bytes gauge process_resident_memory_bytes 4.595712e+07 # HELP process_start_time_seconds Start time of the process since unix epoch in seconds. # TYPE process_start_time_seconds gauge process_start_time_seconds 1.6436681112e+09 # HELP process_cpu_seconds_total Total user and system CPU time spent in seconds. # TYPE process_cpu_seconds_total counter process_cpu_seconds_total 3.3 # HELP process_open_fds Number of open file descriptors. # TYPE process_open_fds gauge process_open_fds 12.0 # HELP process_max_fds Maximum number of open file descriptors. # TYPE process_max_fds gauge process_max_fds 1.048576e+06 # HELP exporter_info Information about the Prometheus Flask exporter # TYPE exporter_info gauge exporter_info{version=\"0.18.7\"} 1.0 # HELP http_request_duration_seconds Flask HTTP request duration in seconds # TYPE http_request_duration_seconds histogram http_request_duration_seconds_bucket{le=\"0.1\",method=\"POST\",path=\"/mutate\",status=\"200\"} 5.0 http_request_duration_seconds_bucket{le=\"0.25\",method=\"POST\",path=\"/mutate\",status=\"200\"} 5.0 http_request_duration_seconds_bucket{le=\"0.5\",method=\"POST\",path=\"/mutate\",status=\"200\"} 5.0 http_request_duration_seconds_bucket{le=\"0.75\",method=\"POST\",path=\"/mutate\",status=\"200\"} 8.0 http_request_duration_seconds_bucket{le=\"1.0\",method=\"POST\",path=\"/mutate\",status=\"200\"} 8.0 http_request_duration_seconds_bucket{le=\"2.5\",method=\"POST\",path=\"/mutate\",status=\"200\"} 9.0 http_request_duration_seconds_bucket{le=\"+Inf\",method=\"POST\",path=\"/mutate\",status=\"200\"} 9.0 http_request_duration_seconds_count{method=\"POST\",path=\"/mutate\",status=\"200\"} 9.0 http_request_duration_seconds_sum{method=\"POST\",path=\"/mutate\",status=\"200\"} 3.6445974350208417 # HELP http_request_duration_seconds_created Flask HTTP request duration in seconds # TYPE http_request_duration_seconds_created gauge http_request_duration_seconds_created{method=\"POST\",path=\"/mutate\",status=\"200\"} 1.643668194758098e+09 # HELP http_request_total Total number of HTTP requests # TYPE http_request_total counter http_request_total{method=\"POST\",status=\"200\"} 9.0 # HELP http_request_created Total number of HTTP requests # TYPE http_request_created gauge http_request_created{method=\"POST\",status=\"200\"} 1.6436681947581613e+09 # HELP http_request_exceptions_total Total number of HTTP requests which resulted in an exception # TYPE http_request_exceptions_total counter # HELP mutate_requests_total Total number of mutate requests # TYPE mutate_requests_total counter mutate_requests_total{allowed=\"False\",status_code=\"403\"} 4.0 mutate_requests_total{allowed=\"True\",status_code=\"202\"} 5.0 # HELP mutate_requests_created Total number of mutate requests # TYPE mutate_requests_created gauge mutate_requests_created{allowed=\"False\",status_code=\"403\"} 1.643760946491879e+09 mutate_requests_created{allowed=\"True\",status_code=\"202\"} 1.6437609592007663e+09","title":"Example"},{"location":"features/namespaced_validation/","text":"Namespaced Validation \u2693\ufe0e Namespaced validation allows restricting validation to specific namespaces. Connaisseur will only verify trust of images deployed to the configured namespaces. This can greatly support initial rollout by stepwise extending the validated namespaces or excluding specific namespaces for which signatures are unfeasible. Enabling namespaced validation, allows roles with edit permissions on namespaces to disable validation for those namespaces. Namespaced validation offers two modes: ignore : ignore all namespaces with label securesystemsengineering.connaisseur/webhook: ignore validate : only validate namespaces with label securesystemsengineering.connaisseur/webhook: validate The desired namespaces must be labelled accordingly, e.g. via: # either kubectl namespaces <namespace> securesystemsengineering.connaisseur/webhook=ignore # or kubectl namespaces <namespace> securesystemsengineering.connaisseur/webhook=validate Configure namespaced validation via the namespacedValidation in helm/values.yaml . Configuration options \u2693\ufe0e namespacedValidation in helm/values.yaml supports the following keys: Key Default Required Description enabled false true or false ; enable namespaced validation otherwise images in all namespaces will be validated. mode ignore ignore or validate ; configure mode of exclusion to either ignore all namespaces with label securesystemsengineering.connaisseur/webhook set to ignore or only validate namespaces with the label set to validate . Example \u2693\ufe0e In helm/values.yaml : namespacedValidation: enabled: true mode: validate Labelling target namespace to be validated: kubectl namespaces validateme securesystemsengineering.connaisseur/webhook=validate","title":"Namespaced Validation"},{"location":"features/namespaced_validation/#namespaced-validation","text":"Namespaced validation allows restricting validation to specific namespaces. Connaisseur will only verify trust of images deployed to the configured namespaces. This can greatly support initial rollout by stepwise extending the validated namespaces or excluding specific namespaces for which signatures are unfeasible. Enabling namespaced validation, allows roles with edit permissions on namespaces to disable validation for those namespaces. Namespaced validation offers two modes: ignore : ignore all namespaces with label securesystemsengineering.connaisseur/webhook: ignore validate : only validate namespaces with label securesystemsengineering.connaisseur/webhook: validate The desired namespaces must be labelled accordingly, e.g. via: # either kubectl namespaces <namespace> securesystemsengineering.connaisseur/webhook=ignore # or kubectl namespaces <namespace> securesystemsengineering.connaisseur/webhook=validate Configure namespaced validation via the namespacedValidation in helm/values.yaml .","title":"Namespaced Validation"},{"location":"features/namespaced_validation/#configuration-options","text":"namespacedValidation in helm/values.yaml supports the following keys: Key Default Required Description enabled false true or false ; enable namespaced validation otherwise images in all namespaces will be validated. mode ignore ignore or validate ; configure mode of exclusion to either ignore all namespaces with label securesystemsengineering.connaisseur/webhook set to ignore or only validate namespaces with the label set to validate .","title":"Configuration options"},{"location":"features/namespaced_validation/#example","text":"In helm/values.yaml : namespacedValidation: enabled: true mode: validate Labelling target namespace to be validated: kubectl namespaces validateme securesystemsengineering.connaisseur/webhook=validate","title":"Example"},{"location":"validators/","text":"Overview \u2693\ufe0e Connaisseur is built to be extendable and currently aims to support the following signing solutions: Docker Content Trust (DCT) / Notary V1 sigstore / Cosign Notary V2 (PLANNED) Feel free to use any or a combination of all solutions. The integration with Connaisseur is detailed on the following pages. For advantages and disadvantages of each solution, please refer to the respective docs.","title":"Overview"},{"location":"validators/#overview","text":"Connaisseur is built to be extendable and currently aims to support the following signing solutions: Docker Content Trust (DCT) / Notary V1 sigstore / Cosign Notary V2 (PLANNED) Feel free to use any or a combination of all solutions. The integration with Connaisseur is detailed on the following pages. For advantages and disadvantages of each solution, please refer to the respective docs.","title":"Overview"},{"location":"validators/notaryv1/","text":"Notary (V1) / DCT \u2693\ufe0e Notary (V1 1 ) works as an external service holding signatures and trust data of artifacts based on The Update Framework (TUF) . Docker Content Trust (DCT) is a client implementation by Docker to manage such trust data for container images like signing images or verifying the corresponding signatures. It is part of the standard Docker CLI ( docker ) and for example provides the docker trust commands. Using DCT, the trust data is per default pushed to the Notary server associated to the container registry. However, not every public container registry provides an associated Notary server and thus support for DCT must be checked for the provider in question. Docker Hub for example, runs an associated Notary server (notary.docker.io) and even uses it to serve trust data for the Docker Official Images . In fact, since Connaisseur's pre-built images are shared via the Connaisseur Docker Hub repository , its own trust data is maintained on Docker Hub's Notary server. Besides the public Notary instances, Notary can also be run as a private or even standalone instance. Harbor for example comes along with an associated Notary instance. Validating a container image via DCT requires a repository's public root key as well as fetching the repository's trust data from the associated Notary server. While DCT relies on trust on first use (TOFU) for repositories' public root keys, Connaisseur enforces manual pinning to a public root key that must be configured in advance. Basic usage \u2693\ufe0e In order to validate signatures using Notary, you will either need to create signing keys and signed images yourself or extract the public root key of other images and configure Connaisseur via validators[*].trust_roots[*].key in helm/values.yaml to pin trust to those keys. Both is described below. However, there is also step-by-step instructions for using Notary in the getting started guide . Creating signing key pairs \u2693\ufe0e You can either create the root key manually or push an image with DCT enabled upon which docker will guide you to set up the keys as described in the next section. In order to generate a public-private root key pair manually, you can use: docker trust key generate root You will be prompted for a password, the private key is automatically imported and a root.pub file is created in your current folder that contains your public key which should look similar to: -----BEGIN PUBLIC KEY----- role: root MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELDzXwqie/P66R3gVpFDWMhxOyol5 YWD/KWnAaEIcJVTYUR+21NJSZz0yL7KLGrv50H9kHai5WWVsVykOZNoZYQ == -----END PUBLIC KEY----- You will only need the actual base64 encoded part for configuring the validators[*].trust_roots[*].key in helm/values.yaml of Connaisseur to validate your images. How to extract the public root key for any image is described below . Creating signatures \u2693\ufe0e Before you can start validating images using the Notary (V1) validator, you'll first need an image which has been signed using DCT. Easiest way to do this is by pushing an image of your choice (e.g. busybox:stable ) to your Docker Hub repository with DCT activated (either set the environment variable DOCKER_CONTENT_TRUST=1 or use the --disable-content-trust=false flag). If you haven't created any signatures for images in the current repository yet, you'll be asked to enter a passphrase for a root key and targets key, which get generated on your machine. Have a look into the TUF documentation to read more about TUF roles and their meanings. If you already have these keys, just enter the required passphrase. DOCKER_CONTENT_TRUST = 1 docker push <your-repo>/busybox:stable > The push refers to repository [ <your-repo>/busybox ] > 5b8c72934dfc: Pushed > stable: digest: sha256:dca71257cd2e72840a21f0323234bb2e33fea6d949fa0f21c5102146f583486b size: 527 > Signing and pushing trust metadata > You are about to create a new root signing key passphrase. This passphrase > will be used to protect the most sensitive key in your signing system. Please > choose a long, complex passphrase and be careful to keep the password and the > key file itself secure and backed up. It is highly recommended that you use a > password manager to generate the passphrase and keep it safe. There will be no > way to recover this key. You can find the key in your config directory. > Enter passphrase for new root key with ID 5fb3e1e: > Repeat passphrase for new root key with ID 5fb3e1e: > Enter passphrase for new repository key with ID 6c2a04c: > Repeat passphrase for new repository key with ID 6c2a04c: > Finished initializing \"<your-repo>/busybox\" The freshly generated keys are directly imported to the Docker client. Private keys reside in ~/.docker/trust/private and public trust data is added to ~/.docker/trust/tuf/ . The created signature for your image is pushed to the public Docker Hub Notary (notary.docker.io). The private keys and password are required whenever a new version of the image is pushed with DCT activated. Getting the public root key \u2693\ufe0e Signature validation via Connaisseur requires the public root key to verify against as a trust anchor. But from where do you get this, especially for public images whose signatures you didn't create? We have created the get_root_key utility to extract the public root key of images. To use it, either use our pre-built image or build the docker image yourself via docker build -t get-public-root-key -f docker/Dockerfile.getRoot . and run it on the image to be verified: # pre-built docker run --rm docker.io/securesystemsengineering/get-public-root-key -i securesystemsengineering/testimage # or self-built docker run --rm get-public-root-key -i securesystemsengineering/testimage > KeyID: 76d211ff8d2317d78ee597dbc43888599d691dbfd073b8226512f0e9848f2508 > Key: -----BEGIN PUBLIC KEY----- > MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe > d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q == > -----END PUBLIC KEY----- The -i ( --image ) option is required and takes the image, for which you want the public key. There is also the -s ( --server ) option, which defines the Notary server that should be used and which defaults to notary.docker.io . The public repository root key resides with the signature data in the Notary instance, so what the get_root_key utility does in the background is just fetching, locating and parsing the public repository root key for the given image. Configuring and running Connaisseur \u2693\ufe0e Now that you either created your own keys and signed images or extracted the public key of other images, you will need to configure Connaisseur to use those keys for validation. This is done via validators in helm/values.yaml . The corresponding entry should look similar to the following (using the extracted public key as trust root): - name : customvalidator type : notaryv1 host : notary.docker.io trust_roots : - name : default key : | # THE DESIRED PUBLIC KEY BELOW -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEOXYta5TgdCwXTCnLU09W5T4M4r9f QQrqJuADP6U7g5r9ICgPSmZuRHP/1AYUfOQW3baveKsT969EfELKj1lfCA== -----END PUBLIC KEY----- You also need to create a corresponding entry in the image policy via policy in helm/values.yaml , for example: - pattern : \"docker.io/<REPOSITORY>/<IMAGE>:*\" # THE DESIRED REPOSITORY validator : customvalidator After installation, you are ready to verify your images against your public key: helm install connaisseur helm --atomic --create-namespace --namespace connaisseur Connaisseur now rejects all images from the given repository that have not been signed based on the provided public key. A quick guide for installation and testing is available in getting started . It also provides a full step-by-step guide. Understanding validation \u2693\ufe0e Using the simple pre-configuration shipped with Connaisseur, it is possible to test validation by deploying some pods: kubectl run test-signed --image = docker.io/securesystemsengineering/testimage:signed > pod/test-signed created kubectl run test-unsigned --image = docker.io/securesystemsengineering/testimage:unsigned > Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request: Unable to find signed digest for image docker.io/securesystemsengineering/testimage:unsigned. # or in case of a signature with a different key > Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request: Failed to verify signature of trust data root. How does Connaisseur validate these requests and convert the images with tags to digests? What happens in the background is that Connaisseur looks up trust data of the image in the root , snapshot , timestamp and targets files (in json format) by querying the API of the Notary server. Trust data syntax is validated against their known schemas and the files' signatures are validated against their respective public keys. The pinned root key is used for the root.json file that in turn contains the other keys which can then be trusted for validation of the remaining trust data ( snapshot.json , timestamp.json , targets.json ). Furthermore, Connaisseur gathers trust data of potential delegations linked in the targets file which can then be used to enforce delegations . At this point, Connaisseur is left with a validated set of trust data. Connaisseur filters the trust data for consistent signed digests that actually relate to the image under validation. In case exactly one trusted digest remains, Connaisseur modifies the admission request and admits it. Otherwise, admission is rejected. While it is obvious to reject an image that does not exhibit a trusted digest, there is the special case of multiple trusted digests. This only occurs in some edge cases, but at this point Connaisseur cannot identify the right digest anymore and consequently has to reject. For more information on TUF roles, please refer to TUF's documentation or checkout this introductory presentation on how the trust data formats work and are validated by Connaisseur. Configuration options \u2693\ufe0e .validators[*] in helm/values.yaml supports the following keys for Notary (V1) (refer to basics for more information on default keys): Key Default Required Description name - See basics . type - notaryv1 ; the validator type must be set to notaryv1 . host - URL of the Notary instance, in which the signatures reside, e.g. notary.docker.io . trust_roots[*].name - See basics . trust_roots[*].key - See basics . ECDSA public root key. auth - Authentication credentials for the Notary server in case the trust data is not public. auth.secret_name - (Preferred over username + password combination.) Name of a Kubernetes secret that must exist in Connaisseur namespace beforehand. Create a file auth.yaml containing: username: <user> password: <password> Run kubectl create secret generic <kube-secret-name> --from-file auth.yaml -n connaisseur to create the secret. auth.username - Username to authenticate with. It is recommended to use auth.secret_name instead. auth.password - Password or access token to authenticate with. It is recommended to use auth.secret_name instead. cert - Self-signed certificate of the Notary instance, if used. Certificate must be supplied in .pem format. is_acr false true if using Azure Container Registry (ACR) as ACR does not offer a health endpoint according to Notary API specs. .policy[*] in helm/values.yaml supports the following additional keys for Notary (V1) (refer to basics for more information on default keys): Key Default Required Description with.delegations - List of delegation names to enforce specific signers to be present. Refer to section on enforcing delegations for more information. Example \u2693\ufe0e validators : - name : docker_essentials type : notaryv1 host : notary.docker.io trust_roots : - name : sse key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- policy : - pattern : \"docker.io/securesystemsengineering/connaisseur:*\" validator : docker_essentials with : key : sse delegations : - belitzphilipp - starkteetje Additional notes \u2693\ufe0e Enforcing delegations \u2693\ufe0e Notary (V1) offers the functionality to delegate trust. To better understand this feature, it's best to have a basic understanding of the TUF key hierarchy, or more specifically the purpose of the root, targets and delegation keys. If you are more interested in this topic, please read the TUF documentation . When creating the signatures of your docker images earlier, two keys were generated -- the root key and the targets key. The root key is the root of all trust and will be used whenever a new image repository is created and needs to be signed. It's also used to rotate all other kinds of keys, thus there is usually only one root key present. The targets key is needed for new signatures on one specific image repository, hence every image repository has its own targets key. Hierarchically speaking, the targets keys are below the root key, as the root key can be used to rotate the targets keys should they get compromised. Delegations will now go one level deeper, meaning they can be used to sign individual image repositories and only need the targets key for rotation purposes, instead of the root key. Also delegation keys are not bound to individual image repositories, so they can be re-used multiple times over different image repositories. So in a sense they can be understood as keys for individual signers. To create a delegation key run: docker trust key generate <key-name> > Generating key for <key-name>... > Enter passphrase for new <key-name> key with ID 9deed25: > Repeat passphrase for new <key-name> key with ID 9deed25: > Successfully generated and loaded private key. Corresponding public key available: <current-directory>/<key-name>.pub This delegation key now needs to be added as a signer to a respective image repository, like the busybox example above . In doing so, you'll be asked for the targets key. docker trust signer add --key <key-name>.pub <key-name> <your-repo>/busybox > Adding signer \"<key-name>\" to <your-repo>/busybox... > Enter passphrase for repository key with ID b0014f8: > Successfully added signer: <key-name> to <your-repo>/busybox If you create a new signature for the image, you'll be asked for your delegation key instead of the targets key, therefore creating a signature using the delegation. > DOCKER_CONTENT_TRUST = 1 docker push <your-repo>/busybox:stable Without further configuration, Connaisseur will accept all delegation signatures for an image that can ultimately be validated against the public root key. Connaisseur can enforce a certain signer/delegation (or multiple) for an image's signature via the with.delegations list inside an image policy rule. Simply add the signer's name to the list. You can also add multiple signer names to the list in which case Connaisseur will enforce that all delegations must have signed a matching image. policy : - pattern : \"<your-repo>/busybox:*\" with : delegations : - <key-name> - <other-key-name> The delegation feature can be useful in complex organisations where certain people may be required to sign specific critical images. Another use case is to sign an image with delegation keys in various stages of your CI and enforce that certain checks were passed, i.e. enforcing the signature of your linter, your security scanner and your software lisence compliance check. Using Azure Container Registry \u2693\ufe0e Using Azure Container Registry (ACR) must be specified in the validator configuration by setting is_acr to true . Moreover, you need to provide credentials of an Azure Identity having at least read access to the ACR (and, thus, to the associated Notary instance). Assuming you have the az cli installed you can create a Service Principal for this by running: # Retrieve the ID of your registry REGISTRY_ID = $( az acr show --name <ACR-NAME> --query 'id' -otsv ) # Create a service principal with the Reader role on your registry az ad sp create-for-rbac --name \"<SERVICE-PRINCIPLE-NAME>\" --role Reader --scopes ${ REGISTRY_ID } Use the resulting applicationID as auth.username , the resulting password as auth.password and set <ACR>.azurecr.io as host in the helm/values.yaml and you're ready to go! Notary does traditionally not carry the version number. However, in differentiation to the new Notary V2 project we decided to add a careful \"(V1)\" whenever we refer to the original project. \u21a9","title":"Notary (V1) / DCT"},{"location":"validators/notaryv1/#notary-v1-dct","text":"Notary (V1 1 ) works as an external service holding signatures and trust data of artifacts based on The Update Framework (TUF) . Docker Content Trust (DCT) is a client implementation by Docker to manage such trust data for container images like signing images or verifying the corresponding signatures. It is part of the standard Docker CLI ( docker ) and for example provides the docker trust commands. Using DCT, the trust data is per default pushed to the Notary server associated to the container registry. However, not every public container registry provides an associated Notary server and thus support for DCT must be checked for the provider in question. Docker Hub for example, runs an associated Notary server (notary.docker.io) and even uses it to serve trust data for the Docker Official Images . In fact, since Connaisseur's pre-built images are shared via the Connaisseur Docker Hub repository , its own trust data is maintained on Docker Hub's Notary server. Besides the public Notary instances, Notary can also be run as a private or even standalone instance. Harbor for example comes along with an associated Notary instance. Validating a container image via DCT requires a repository's public root key as well as fetching the repository's trust data from the associated Notary server. While DCT relies on trust on first use (TOFU) for repositories' public root keys, Connaisseur enforces manual pinning to a public root key that must be configured in advance.","title":"Notary (V1) / DCT"},{"location":"validators/notaryv1/#basic-usage","text":"In order to validate signatures using Notary, you will either need to create signing keys and signed images yourself or extract the public root key of other images and configure Connaisseur via validators[*].trust_roots[*].key in helm/values.yaml to pin trust to those keys. Both is described below. However, there is also step-by-step instructions for using Notary in the getting started guide .","title":"Basic usage"},{"location":"validators/notaryv1/#creating-signing-key-pairs","text":"You can either create the root key manually or push an image with DCT enabled upon which docker will guide you to set up the keys as described in the next section. In order to generate a public-private root key pair manually, you can use: docker trust key generate root You will be prompted for a password, the private key is automatically imported and a root.pub file is created in your current folder that contains your public key which should look similar to: -----BEGIN PUBLIC KEY----- role: root MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELDzXwqie/P66R3gVpFDWMhxOyol5 YWD/KWnAaEIcJVTYUR+21NJSZz0yL7KLGrv50H9kHai5WWVsVykOZNoZYQ == -----END PUBLIC KEY----- You will only need the actual base64 encoded part for configuring the validators[*].trust_roots[*].key in helm/values.yaml of Connaisseur to validate your images. How to extract the public root key for any image is described below .","title":"Creating signing key pairs"},{"location":"validators/notaryv1/#creating-signatures","text":"Before you can start validating images using the Notary (V1) validator, you'll first need an image which has been signed using DCT. Easiest way to do this is by pushing an image of your choice (e.g. busybox:stable ) to your Docker Hub repository with DCT activated (either set the environment variable DOCKER_CONTENT_TRUST=1 or use the --disable-content-trust=false flag). If you haven't created any signatures for images in the current repository yet, you'll be asked to enter a passphrase for a root key and targets key, which get generated on your machine. Have a look into the TUF documentation to read more about TUF roles and their meanings. If you already have these keys, just enter the required passphrase. DOCKER_CONTENT_TRUST = 1 docker push <your-repo>/busybox:stable > The push refers to repository [ <your-repo>/busybox ] > 5b8c72934dfc: Pushed > stable: digest: sha256:dca71257cd2e72840a21f0323234bb2e33fea6d949fa0f21c5102146f583486b size: 527 > Signing and pushing trust metadata > You are about to create a new root signing key passphrase. This passphrase > will be used to protect the most sensitive key in your signing system. Please > choose a long, complex passphrase and be careful to keep the password and the > key file itself secure and backed up. It is highly recommended that you use a > password manager to generate the passphrase and keep it safe. There will be no > way to recover this key. You can find the key in your config directory. > Enter passphrase for new root key with ID 5fb3e1e: > Repeat passphrase for new root key with ID 5fb3e1e: > Enter passphrase for new repository key with ID 6c2a04c: > Repeat passphrase for new repository key with ID 6c2a04c: > Finished initializing \"<your-repo>/busybox\" The freshly generated keys are directly imported to the Docker client. Private keys reside in ~/.docker/trust/private and public trust data is added to ~/.docker/trust/tuf/ . The created signature for your image is pushed to the public Docker Hub Notary (notary.docker.io). The private keys and password are required whenever a new version of the image is pushed with DCT activated.","title":"Creating signatures"},{"location":"validators/notaryv1/#getting-the-public-root-key","text":"Signature validation via Connaisseur requires the public root key to verify against as a trust anchor. But from where do you get this, especially for public images whose signatures you didn't create? We have created the get_root_key utility to extract the public root key of images. To use it, either use our pre-built image or build the docker image yourself via docker build -t get-public-root-key -f docker/Dockerfile.getRoot . and run it on the image to be verified: # pre-built docker run --rm docker.io/securesystemsengineering/get-public-root-key -i securesystemsengineering/testimage # or self-built docker run --rm get-public-root-key -i securesystemsengineering/testimage > KeyID: 76d211ff8d2317d78ee597dbc43888599d691dbfd073b8226512f0e9848f2508 > Key: -----BEGIN PUBLIC KEY----- > MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe > d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q == > -----END PUBLIC KEY----- The -i ( --image ) option is required and takes the image, for which you want the public key. There is also the -s ( --server ) option, which defines the Notary server that should be used and which defaults to notary.docker.io . The public repository root key resides with the signature data in the Notary instance, so what the get_root_key utility does in the background is just fetching, locating and parsing the public repository root key for the given image.","title":"Getting the public root key"},{"location":"validators/notaryv1/#configuring-and-running-connaisseur","text":"Now that you either created your own keys and signed images or extracted the public key of other images, you will need to configure Connaisseur to use those keys for validation. This is done via validators in helm/values.yaml . The corresponding entry should look similar to the following (using the extracted public key as trust root): - name : customvalidator type : notaryv1 host : notary.docker.io trust_roots : - name : default key : | # THE DESIRED PUBLIC KEY BELOW -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEOXYta5TgdCwXTCnLU09W5T4M4r9f QQrqJuADP6U7g5r9ICgPSmZuRHP/1AYUfOQW3baveKsT969EfELKj1lfCA== -----END PUBLIC KEY----- You also need to create a corresponding entry in the image policy via policy in helm/values.yaml , for example: - pattern : \"docker.io/<REPOSITORY>/<IMAGE>:*\" # THE DESIRED REPOSITORY validator : customvalidator After installation, you are ready to verify your images against your public key: helm install connaisseur helm --atomic --create-namespace --namespace connaisseur Connaisseur now rejects all images from the given repository that have not been signed based on the provided public key. A quick guide for installation and testing is available in getting started . It also provides a full step-by-step guide.","title":"Configuring and running Connaisseur"},{"location":"validators/notaryv1/#understanding-validation","text":"Using the simple pre-configuration shipped with Connaisseur, it is possible to test validation by deploying some pods: kubectl run test-signed --image = docker.io/securesystemsengineering/testimage:signed > pod/test-signed created kubectl run test-unsigned --image = docker.io/securesystemsengineering/testimage:unsigned > Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request: Unable to find signed digest for image docker.io/securesystemsengineering/testimage:unsigned. # or in case of a signature with a different key > Error from server: admission webhook \"connaisseur-svc.connaisseur.svc\" denied the request: Failed to verify signature of trust data root. How does Connaisseur validate these requests and convert the images with tags to digests? What happens in the background is that Connaisseur looks up trust data of the image in the root , snapshot , timestamp and targets files (in json format) by querying the API of the Notary server. Trust data syntax is validated against their known schemas and the files' signatures are validated against their respective public keys. The pinned root key is used for the root.json file that in turn contains the other keys which can then be trusted for validation of the remaining trust data ( snapshot.json , timestamp.json , targets.json ). Furthermore, Connaisseur gathers trust data of potential delegations linked in the targets file which can then be used to enforce delegations . At this point, Connaisseur is left with a validated set of trust data. Connaisseur filters the trust data for consistent signed digests that actually relate to the image under validation. In case exactly one trusted digest remains, Connaisseur modifies the admission request and admits it. Otherwise, admission is rejected. While it is obvious to reject an image that does not exhibit a trusted digest, there is the special case of multiple trusted digests. This only occurs in some edge cases, but at this point Connaisseur cannot identify the right digest anymore and consequently has to reject. For more information on TUF roles, please refer to TUF's documentation or checkout this introductory presentation on how the trust data formats work and are validated by Connaisseur.","title":"Understanding validation"},{"location":"validators/notaryv1/#configuration-options","text":".validators[*] in helm/values.yaml supports the following keys for Notary (V1) (refer to basics for more information on default keys): Key Default Required Description name - See basics . type - notaryv1 ; the validator type must be set to notaryv1 . host - URL of the Notary instance, in which the signatures reside, e.g. notary.docker.io . trust_roots[*].name - See basics . trust_roots[*].key - See basics . ECDSA public root key. auth - Authentication credentials for the Notary server in case the trust data is not public. auth.secret_name - (Preferred over username + password combination.) Name of a Kubernetes secret that must exist in Connaisseur namespace beforehand. Create a file auth.yaml containing: username: <user> password: <password> Run kubectl create secret generic <kube-secret-name> --from-file auth.yaml -n connaisseur to create the secret. auth.username - Username to authenticate with. It is recommended to use auth.secret_name instead. auth.password - Password or access token to authenticate with. It is recommended to use auth.secret_name instead. cert - Self-signed certificate of the Notary instance, if used. Certificate must be supplied in .pem format. is_acr false true if using Azure Container Registry (ACR) as ACR does not offer a health endpoint according to Notary API specs. .policy[*] in helm/values.yaml supports the following additional keys for Notary (V1) (refer to basics for more information on default keys): Key Default Required Description with.delegations - List of delegation names to enforce specific signers to be present. Refer to section on enforcing delegations for more information.","title":"Configuration options"},{"location":"validators/notaryv1/#example","text":"validators : - name : docker_essentials type : notaryv1 host : notary.docker.io trust_roots : - name : sse key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- policy : - pattern : \"docker.io/securesystemsengineering/connaisseur:*\" validator : docker_essentials with : key : sse delegations : - belitzphilipp - starkteetje","title":"Example"},{"location":"validators/notaryv1/#additional-notes","text":"","title":"Additional notes"},{"location":"validators/notaryv1/#enforcing-delegations","text":"Notary (V1) offers the functionality to delegate trust. To better understand this feature, it's best to have a basic understanding of the TUF key hierarchy, or more specifically the purpose of the root, targets and delegation keys. If you are more interested in this topic, please read the TUF documentation . When creating the signatures of your docker images earlier, two keys were generated -- the root key and the targets key. The root key is the root of all trust and will be used whenever a new image repository is created and needs to be signed. It's also used to rotate all other kinds of keys, thus there is usually only one root key present. The targets key is needed for new signatures on one specific image repository, hence every image repository has its own targets key. Hierarchically speaking, the targets keys are below the root key, as the root key can be used to rotate the targets keys should they get compromised. Delegations will now go one level deeper, meaning they can be used to sign individual image repositories and only need the targets key for rotation purposes, instead of the root key. Also delegation keys are not bound to individual image repositories, so they can be re-used multiple times over different image repositories. So in a sense they can be understood as keys for individual signers. To create a delegation key run: docker trust key generate <key-name> > Generating key for <key-name>... > Enter passphrase for new <key-name> key with ID 9deed25: > Repeat passphrase for new <key-name> key with ID 9deed25: > Successfully generated and loaded private key. Corresponding public key available: <current-directory>/<key-name>.pub This delegation key now needs to be added as a signer to a respective image repository, like the busybox example above . In doing so, you'll be asked for the targets key. docker trust signer add --key <key-name>.pub <key-name> <your-repo>/busybox > Adding signer \"<key-name>\" to <your-repo>/busybox... > Enter passphrase for repository key with ID b0014f8: > Successfully added signer: <key-name> to <your-repo>/busybox If you create a new signature for the image, you'll be asked for your delegation key instead of the targets key, therefore creating a signature using the delegation. > DOCKER_CONTENT_TRUST = 1 docker push <your-repo>/busybox:stable Without further configuration, Connaisseur will accept all delegation signatures for an image that can ultimately be validated against the public root key. Connaisseur can enforce a certain signer/delegation (or multiple) for an image's signature via the with.delegations list inside an image policy rule. Simply add the signer's name to the list. You can also add multiple signer names to the list in which case Connaisseur will enforce that all delegations must have signed a matching image. policy : - pattern : \"<your-repo>/busybox:*\" with : delegations : - <key-name> - <other-key-name> The delegation feature can be useful in complex organisations where certain people may be required to sign specific critical images. Another use case is to sign an image with delegation keys in various stages of your CI and enforce that certain checks were passed, i.e. enforcing the signature of your linter, your security scanner and your software lisence compliance check.","title":"Enforcing delegations"},{"location":"validators/notaryv1/#using-azure-container-registry","text":"Using Azure Container Registry (ACR) must be specified in the validator configuration by setting is_acr to true . Moreover, you need to provide credentials of an Azure Identity having at least read access to the ACR (and, thus, to the associated Notary instance). Assuming you have the az cli installed you can create a Service Principal for this by running: # Retrieve the ID of your registry REGISTRY_ID = $( az acr show --name <ACR-NAME> --query 'id' -otsv ) # Create a service principal with the Reader role on your registry az ad sp create-for-rbac --name \"<SERVICE-PRINCIPLE-NAME>\" --role Reader --scopes ${ REGISTRY_ID } Use the resulting applicationID as auth.username , the resulting password as auth.password and set <ACR>.azurecr.io as host in the helm/values.yaml and you're ready to go! Notary does traditionally not carry the version number. However, in differentiation to the new Notary V2 project we decided to add a careful \"(V1)\" whenever we refer to the original project. \u21a9","title":"Using Azure Container Registry"},{"location":"validators/notaryv2/","text":"Notary V2 \u2693\ufe0e TBD - Notary V2 has not yet been integrated with Connaisseur.","title":"Notary V2"},{"location":"validators/notaryv2/#notary-v2","text":"TBD - Notary V2 has not yet been integrated with Connaisseur.","title":"Notary V2"},{"location":"validators/sigstore_cosign/","text":"sigstore / Cosign \u2693\ufe0e sigstore is a Linux Foundation project that aims to provide public software signing and transparency to improve open source supply chain security. As part of the sigstore project, Cosign allows seamless container signing, verification and storage. You can read more about it here . Connaisseur currently supports the elementary function of verifying Cosign-generated signatures based on the following types of keys: Locally-generated key pair KMS (via reference URI or export of the public key ) Hardware-based token ( export the public key ) We plan to expose further features of Cosign and sigstore in upcoming releases, so stay tuned! Basic usage \u2693\ufe0e Getting started with Cosign is very well described in the docs . You can download Cosign from its GitHub repository . In short: After installation, a keypair is generated via: cosign generate-key-pair You will be prompted to set a password, after which a private ( cosign.key ) and public ( cosign.pub ) key are created. You can then use Cosign to sign a container image using: # Here, ${IMAGE} is REPOSITORY/IMAGE_NAME:TAG cosign sign -key cosign.key ${ IMAGE } The created signature can be verfied via: cosign verify -key cosign.pub ${ IMAGE } To use Connaisseur with Cosign, configure a validator in helm/values.yaml with the generated public key ( cosign.pub ) as a trust root. The entry in .validators should look something like this (make sure to add your own public key to trust root default ): - name : customvalidator type : cosign trust_roots : - name : default key : | # YOUR PUBLIC KEY BELOW -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- In .policy , add a pattern to match your public key to your own repository: - pattern : \"docker.io/securesystemsengineering/testimage:co*\" # YOUR REPOSITORY validator : customvalidator After installation, you are ready to verify your images against your public key: helm install connaisseur helm --atomic --create-namespace --namespace connaisseur A quick guide for installation and testing is available in getting started . In case you just use the default values for the validator and image policy given above, you are able to successfully validate our signed testimage: kubectl run signed --image = docker.io/securesystemsengineering/testimage:co-signed And compare this to the unsigned image: kubectl run unsigned --image = docker.io/securesystemsengineering/testimage:co-unsigned Or signed with a different key: kubectl run altsigned --image = docker.io/securesystemsengineering/testimage:co-signed-alt Configuration options \u2693\ufe0e .validators[*] in helm/values.yaml supports the following keys for Cosign (refer to basics for more information on default keys): Key Default Required Description name See basics . type cosign ; the validator type must be set to cosign . trust_roots[*].name See basics . trust_roots[*].key See basics . ECDSA public key from cosign.pub file or KMS URI . See additional notes below . host Not yet implemented. auth. Authentication credentials for private registries. See additional notes below . auth.secret_name Name of a Kubernetes secret in Connaisseur namespace that contains dockerconfigjson for registry authentication. See additional notes below . auth.k8s_keychain false When true, pass --k8s-keychain argument to cosign verify in order to use workload identities for authentication. See additional notes below . cert A certificate in PEM format for private registries. .policy[*] in helm/values.yaml supports the following additional keys and modifications for sigstore/Cosign (refer to basics for more information on default keys): Key Default Required Description with.trust_root - Setting the name of trust root to \"*\" enables verification of multiple trust roots. Refer to section on multi-signature verification for more information. with.threshold - - Minimum number of signatures required in case with.trust_root is set to \"*\" . Refer to section on multi-signature verification for more information. with.required [] - Array of required trust roots referenced by name in case with.trust_root is set to \"*\" . Refer to section on multi-signature verification for more information. Example \u2693\ufe0e validators : - name : myvalidator type : cosign trust_roots : - name : mykey key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- policy : - pattern : \"docker.io/securesystemsengineering/testimage:co-*\" validator : myvalidator with : key : mykey Additional notes \u2693\ufe0e Authentication \u2693\ufe0e When using a private registry for images and signature data, the credentials need to be provided to Connaisseur. There are two ways to do this. dockerconfigjson \u2693\ufe0e Create a dockerconfigjson Kubernetes secret in the Connaisseur namespace and pass the secret name to Connaisseur as auth.secret_name . The secret can for example be created directly from your local config.json (for docker this resides in ~/.docker/config.json ): kubectl create secret generic my-secret \\ --from-file = .dockerconfigjson = path/to/config.json \\ --type = kubernetes.io/dockerconfigjson \\ -n connaisseur The secret can also be generated directly from supplied credentials (which may differ from your local config.json , using: kubectl create secret docker-registry my-secret \\ --docker-server = https://index.docker.io/v1/ \\ --docker-username = '<your username>' \\ --docker-password = '<your password>' \\ -n connaisseur Note : At present, it seems to be necessary to suffix your registry server URL with /v1/ . This may become unnecessary in the future. In the above cases, the secret name in Connaisseur configuration would be secret_name: my-secret . It is possible to provide one Kubernetes secret with a config.json for authentication to multiple private registries and referencing this in multiple validators. k8s_keychain \u2693\ufe0e Specification of auth.k8s_keychain: true in the validator configuration passes the --k8s-keychain to cosign when performing image validation. Thus, k8schain is used by cosign to pick up ambient registry credentials from the environment and for example use workload identities in case of common cloud providers. For example, when validating against an ECR private repository, the credentials of an IAM user allowed to perform actions ecr:GetAuthorizationToken , ecr:BatchGetImage , and ecr:GetDownloadUrlForLayer could be added to the secret connaisseur-env-secrets : apiVersion : v1 kind : Secret type : Opaque metadata : name : connaisseur-env-secrets ... data : AWS_ACCESS_KEY_ID : *** AWS_SECRET_ACCESS_KEY : *** ... If k8s_keychain is set to true in the validator configuration, cosign will log into ECR at time of validation. See this cosign pull request for more details. KMS Support \u2693\ufe0e Connaisseur supports Cosign's URI-based KMS integration to manage the signing and verification keys. Simply configure the trust root key value as the respective URI. In case of a Kubernetes secret , this would take the following form: - name : myvalidator type : cosign trust_roots : - name : mykey key : k8s://connaisseur/cosignkeys For that specific case of a Kubernetes secret, make sure to place it in a suitable namespace and grant Connaisseur access to it 1 . Most other KMS will require credentials for authentication that must be provided via environment variables. Such environment variables can be injected into Connaisseur via deployment.envs in helm/values.yaml , e.g.: envs : VAULT_ADDR : myvault.com VAULT_TOKEN : secrettoken Multi-signature verification \u2693\ufe0e This is currently an experimental feature that might be unstable over time. As such, it is not part of our semantic versioning guarantees and we take the liberty to adjust or remove it with any version at any time without incrementing MAJOR or MINOR. Connaisseur can verify multiple signatures for a single image. It is possible to configure a threshold number and specific set of required valid signatures. This allows to implement several advanced use cases (and policies): Five maintainers of a repository are able to sign a single derived image, however at least 3 signatures are required for the image to be valid. In a CI pipeline, a container image is signed directly after pushing by the build job and at a later time by passing quality gates such as security scanners or integration tests, each with their own key (trust root). Validation requires all of these signatures for deployment to enforce integrity and quality gates. A mixture of the above use cases whereby several specific trust roots are enforced (e.g. automation tools) and the overall number of signatures has to surpass a certain threshold (e.g. at least one of the testers admits). Key rotation is possible by adding a new key as an additional key and require at least one valid signature. Multi-signature verification is scoped to the trust roots specified within a referenced validator. Consider the following validator configuration: validators : - name : multicosigner type : cosign trust_roots : - name : alice key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEusIAt6EJ3YrTHdg2qkWVS0KuotWQ wHDtyaXlq7Nhj8279+1u/l5pZhXJPW8PnGRRLdO5NbsuM6aT7pOcP100uw== -----END PUBLIC KEY----- - name : bob key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE01DasuXJ4rfzAEXsURSnbq4QzJ6o EJ2amYV/CBKqEhhl8fDESxsmbdqtBiZkDV2C3znIwV16SsJlRRYO+UrrAQ== -----END PUBLIC KEY----- - name : charlie key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEEHBUYJVrH+aFYJPuryEkRyE6m0m4 ANj+o/oW5fLRiEiXp0kbhkpLJR1LSwKYiX5Toxe3ePcuYpcWZn8Vqe3+oA== -----END PUBLIC KEY----- The trust roots alice , bob , and charlie are all included for verification in case .policy[*].with.trust_root is set to \"*\" (note that this is a special flag, not a real wildcard): - pattern : \"*:*\" validator : multicosigner with : trust_root : \"*\" As neither threshold nor required are specified, Connaisseur will require signatures of all trust roots ( alice , bob , and charlie ) and deny an image otherwise. If either threshold or required is specified, it takes precedence. For example, it is possible to configure a threshold number of required signatures via the threshold key: - pattern : \"*:*\" validator : multicosigner with : trust_root : \"*\" threshold : 2 In this case, valid signatures of two or more out of the three trust roots are required for admittance. Using the required key, it is possible to enforce specific trusted roots: - pattern : \"*:*\" validator : multicosigner with : trust_root : \"*\" required : [ \"alice\" , \"bob\" ] Now, only images with valid signatures of trust roots alice and bob are admitted. It is possible to combine threshold and required keys: - pattern : \"*:*\" validator : multicosigner with : trust_root : \"*\" threshold : 3 required : [ \"alice\" , \"bob\" ] Thus, at least 3 valid signatures are required and alice and bob must be among those. Verification against transparency log \u2693\ufe0e Connaisseur already verifies signatures against the transparency log. However, optional enforcement of transparency log is only planned in upcoming releases. Keyless signatures \u2693\ufe0e Keyless signatures have not yet been implemented but are planned in upcoming releases. The corresponding role and rolebinding should look similar to the following: apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : connaisseur-kms-role namespace : connaisseur # namespace of respective k8s secret, might have to change that labels : app.kubernetes.io/name : connaisseur rules : - apiGroups : [ \"*\" ] resources : [ \"secrets\" ] verbs : [ \"get\" ] --- apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : connaisseur-kms-rolebinding namespace : connaisseur # namespace of respective k8s secret, might have to change that labels : app.kubernetes.io/name : connaisseur subjects : - kind : ServiceAccount name : connaisseur-serviceaccount namespace : connaisseur # Connaisseur's namespace, might have to change that roleRef : kind : Role name : connaisseur-kms-role apiGroup : rbac.authorization.k8s.io Make sure to adjust it as needed. \u21a9","title":"sigstore / Cosign"},{"location":"validators/sigstore_cosign/#sigstore-cosign","text":"sigstore is a Linux Foundation project that aims to provide public software signing and transparency to improve open source supply chain security. As part of the sigstore project, Cosign allows seamless container signing, verification and storage. You can read more about it here . Connaisseur currently supports the elementary function of verifying Cosign-generated signatures based on the following types of keys: Locally-generated key pair KMS (via reference URI or export of the public key ) Hardware-based token ( export the public key ) We plan to expose further features of Cosign and sigstore in upcoming releases, so stay tuned!","title":"sigstore / Cosign"},{"location":"validators/sigstore_cosign/#basic-usage","text":"Getting started with Cosign is very well described in the docs . You can download Cosign from its GitHub repository . In short: After installation, a keypair is generated via: cosign generate-key-pair You will be prompted to set a password, after which a private ( cosign.key ) and public ( cosign.pub ) key are created. You can then use Cosign to sign a container image using: # Here, ${IMAGE} is REPOSITORY/IMAGE_NAME:TAG cosign sign -key cosign.key ${ IMAGE } The created signature can be verfied via: cosign verify -key cosign.pub ${ IMAGE } To use Connaisseur with Cosign, configure a validator in helm/values.yaml with the generated public key ( cosign.pub ) as a trust root. The entry in .validators should look something like this (make sure to add your own public key to trust root default ): - name : customvalidator type : cosign trust_roots : - name : default key : | # YOUR PUBLIC KEY BELOW -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- In .policy , add a pattern to match your public key to your own repository: - pattern : \"docker.io/securesystemsengineering/testimage:co*\" # YOUR REPOSITORY validator : customvalidator After installation, you are ready to verify your images against your public key: helm install connaisseur helm --atomic --create-namespace --namespace connaisseur A quick guide for installation and testing is available in getting started . In case you just use the default values for the validator and image policy given above, you are able to successfully validate our signed testimage: kubectl run signed --image = docker.io/securesystemsengineering/testimage:co-signed And compare this to the unsigned image: kubectl run unsigned --image = docker.io/securesystemsengineering/testimage:co-unsigned Or signed with a different key: kubectl run altsigned --image = docker.io/securesystemsengineering/testimage:co-signed-alt","title":"Basic usage"},{"location":"validators/sigstore_cosign/#configuration-options","text":".validators[*] in helm/values.yaml supports the following keys for Cosign (refer to basics for more information on default keys): Key Default Required Description name See basics . type cosign ; the validator type must be set to cosign . trust_roots[*].name See basics . trust_roots[*].key See basics . ECDSA public key from cosign.pub file or KMS URI . See additional notes below . host Not yet implemented. auth. Authentication credentials for private registries. See additional notes below . auth.secret_name Name of a Kubernetes secret in Connaisseur namespace that contains dockerconfigjson for registry authentication. See additional notes below . auth.k8s_keychain false When true, pass --k8s-keychain argument to cosign verify in order to use workload identities for authentication. See additional notes below . cert A certificate in PEM format for private registries. .policy[*] in helm/values.yaml supports the following additional keys and modifications for sigstore/Cosign (refer to basics for more information on default keys): Key Default Required Description with.trust_root - Setting the name of trust root to \"*\" enables verification of multiple trust roots. Refer to section on multi-signature verification for more information. with.threshold - - Minimum number of signatures required in case with.trust_root is set to \"*\" . Refer to section on multi-signature verification for more information. with.required [] - Array of required trust roots referenced by name in case with.trust_root is set to \"*\" . Refer to section on multi-signature verification for more information.","title":"Configuration options"},{"location":"validators/sigstore_cosign/#example","text":"validators : - name : myvalidator type : cosign trust_roots : - name : mykey key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA== -----END PUBLIC KEY----- policy : - pattern : \"docker.io/securesystemsengineering/testimage:co-*\" validator : myvalidator with : key : mykey","title":"Example"},{"location":"validators/sigstore_cosign/#additional-notes","text":"","title":"Additional notes"},{"location":"validators/sigstore_cosign/#authentication","text":"When using a private registry for images and signature data, the credentials need to be provided to Connaisseur. There are two ways to do this.","title":"Authentication"},{"location":"validators/sigstore_cosign/#dockerconfigjson","text":"Create a dockerconfigjson Kubernetes secret in the Connaisseur namespace and pass the secret name to Connaisseur as auth.secret_name . The secret can for example be created directly from your local config.json (for docker this resides in ~/.docker/config.json ): kubectl create secret generic my-secret \\ --from-file = .dockerconfigjson = path/to/config.json \\ --type = kubernetes.io/dockerconfigjson \\ -n connaisseur The secret can also be generated directly from supplied credentials (which may differ from your local config.json , using: kubectl create secret docker-registry my-secret \\ --docker-server = https://index.docker.io/v1/ \\ --docker-username = '<your username>' \\ --docker-password = '<your password>' \\ -n connaisseur Note : At present, it seems to be necessary to suffix your registry server URL with /v1/ . This may become unnecessary in the future. In the above cases, the secret name in Connaisseur configuration would be secret_name: my-secret . It is possible to provide one Kubernetes secret with a config.json for authentication to multiple private registries and referencing this in multiple validators.","title":"dockerconfigjson"},{"location":"validators/sigstore_cosign/#k8s_keychain","text":"Specification of auth.k8s_keychain: true in the validator configuration passes the --k8s-keychain to cosign when performing image validation. Thus, k8schain is used by cosign to pick up ambient registry credentials from the environment and for example use workload identities in case of common cloud providers. For example, when validating against an ECR private repository, the credentials of an IAM user allowed to perform actions ecr:GetAuthorizationToken , ecr:BatchGetImage , and ecr:GetDownloadUrlForLayer could be added to the secret connaisseur-env-secrets : apiVersion : v1 kind : Secret type : Opaque metadata : name : connaisseur-env-secrets ... data : AWS_ACCESS_KEY_ID : *** AWS_SECRET_ACCESS_KEY : *** ... If k8s_keychain is set to true in the validator configuration, cosign will log into ECR at time of validation. See this cosign pull request for more details.","title":"k8s_keychain"},{"location":"validators/sigstore_cosign/#kms-support","text":"Connaisseur supports Cosign's URI-based KMS integration to manage the signing and verification keys. Simply configure the trust root key value as the respective URI. In case of a Kubernetes secret , this would take the following form: - name : myvalidator type : cosign trust_roots : - name : mykey key : k8s://connaisseur/cosignkeys For that specific case of a Kubernetes secret, make sure to place it in a suitable namespace and grant Connaisseur access to it 1 . Most other KMS will require credentials for authentication that must be provided via environment variables. Such environment variables can be injected into Connaisseur via deployment.envs in helm/values.yaml , e.g.: envs : VAULT_ADDR : myvault.com VAULT_TOKEN : secrettoken","title":"KMS Support"},{"location":"validators/sigstore_cosign/#multi-signature-verification","text":"This is currently an experimental feature that might be unstable over time. As such, it is not part of our semantic versioning guarantees and we take the liberty to adjust or remove it with any version at any time without incrementing MAJOR or MINOR. Connaisseur can verify multiple signatures for a single image. It is possible to configure a threshold number and specific set of required valid signatures. This allows to implement several advanced use cases (and policies): Five maintainers of a repository are able to sign a single derived image, however at least 3 signatures are required for the image to be valid. In a CI pipeline, a container image is signed directly after pushing by the build job and at a later time by passing quality gates such as security scanners or integration tests, each with their own key (trust root). Validation requires all of these signatures for deployment to enforce integrity and quality gates. A mixture of the above use cases whereby several specific trust roots are enforced (e.g. automation tools) and the overall number of signatures has to surpass a certain threshold (e.g. at least one of the testers admits). Key rotation is possible by adding a new key as an additional key and require at least one valid signature. Multi-signature verification is scoped to the trust roots specified within a referenced validator. Consider the following validator configuration: validators : - name : multicosigner type : cosign trust_roots : - name : alice key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEusIAt6EJ3YrTHdg2qkWVS0KuotWQ wHDtyaXlq7Nhj8279+1u/l5pZhXJPW8PnGRRLdO5NbsuM6aT7pOcP100uw== -----END PUBLIC KEY----- - name : bob key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE01DasuXJ4rfzAEXsURSnbq4QzJ6o EJ2amYV/CBKqEhhl8fDESxsmbdqtBiZkDV2C3znIwV16SsJlRRYO+UrrAQ== -----END PUBLIC KEY----- - name : charlie key : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEEHBUYJVrH+aFYJPuryEkRyE6m0m4 ANj+o/oW5fLRiEiXp0kbhkpLJR1LSwKYiX5Toxe3ePcuYpcWZn8Vqe3+oA== -----END PUBLIC KEY----- The trust roots alice , bob , and charlie are all included for verification in case .policy[*].with.trust_root is set to \"*\" (note that this is a special flag, not a real wildcard): - pattern : \"*:*\" validator : multicosigner with : trust_root : \"*\" As neither threshold nor required are specified, Connaisseur will require signatures of all trust roots ( alice , bob , and charlie ) and deny an image otherwise. If either threshold or required is specified, it takes precedence. For example, it is possible to configure a threshold number of required signatures via the threshold key: - pattern : \"*:*\" validator : multicosigner with : trust_root : \"*\" threshold : 2 In this case, valid signatures of two or more out of the three trust roots are required for admittance. Using the required key, it is possible to enforce specific trusted roots: - pattern : \"*:*\" validator : multicosigner with : trust_root : \"*\" required : [ \"alice\" , \"bob\" ] Now, only images with valid signatures of trust roots alice and bob are admitted. It is possible to combine threshold and required keys: - pattern : \"*:*\" validator : multicosigner with : trust_root : \"*\" threshold : 3 required : [ \"alice\" , \"bob\" ] Thus, at least 3 valid signatures are required and alice and bob must be among those.","title":"Multi-signature verification"},{"location":"validators/sigstore_cosign/#verification-against-transparency-log","text":"Connaisseur already verifies signatures against the transparency log. However, optional enforcement of transparency log is only planned in upcoming releases.","title":"Verification against transparency log"},{"location":"validators/sigstore_cosign/#keyless-signatures","text":"Keyless signatures have not yet been implemented but are planned in upcoming releases. The corresponding role and rolebinding should look similar to the following: apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : connaisseur-kms-role namespace : connaisseur # namespace of respective k8s secret, might have to change that labels : app.kubernetes.io/name : connaisseur rules : - apiGroups : [ \"*\" ] resources : [ \"secrets\" ] verbs : [ \"get\" ] --- apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : connaisseur-kms-rolebinding namespace : connaisseur # namespace of respective k8s secret, might have to change that labels : app.kubernetes.io/name : connaisseur subjects : - kind : ServiceAccount name : connaisseur-serviceaccount namespace : connaisseur # Connaisseur's namespace, might have to change that roleRef : kind : Role name : connaisseur-kms-role apiGroup : rbac.authorization.k8s.io Make sure to adjust it as needed. \u21a9","title":"Keyless signatures"}]}